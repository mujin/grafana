{"version":3,"file":"8706.f2ec432d1a549841cf1d.js","mappings":"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","sources":["webpack://grafana/./public/app/core/components/TimelineChart/timeline.ts","webpack://grafana/./public/app/core/components/TimelineChart/utils.ts","webpack://grafana/./public/app/plugins/panel/barchart/distribute.ts","webpack://grafana/./public/app/plugins/panel/barchart/quadtree.ts"],"sourcesContent":["import uPlot, { Series } from 'uplot';\n\nimport { GrafanaTheme2, TimeRange, colorManipulator } from '@grafana/data';\nimport { TimelineValueAlignment, VisibilityMode } from '@grafana/schema';\nimport { FIXED_UNIT } from '@grafana/ui';\nimport { distribute, SPACE_BETWEEN } from 'app/plugins/panel/barchart/distribute';\nimport { Quadtree, Rect } from 'app/plugins/panel/barchart/quadtree';\nimport { FieldConfig as StateTimeLineFieldConfig } from 'app/plugins/panel/state-timeline/panelcfg.gen';\nimport { FieldConfig as StatusHistoryFieldConfig } from 'app/plugins/panel/status-history/panelcfg.gen';\n\nimport { TimelineMode } from './utils';\n\nconst { round, min, ceil } = Math;\n\nconst textPadding = 2;\n\nlet pxPerChar = 6;\n\nconst laneDistr = SPACE_BETWEEN;\n\ntype WalkCb = (idx: number, offPx: number, dimPx: number) => void;\n\nfunction walk(rowHeight: number, yIdx: number | null, count: number, dim: number, draw: WalkCb) {\n  distribute(count, rowHeight, laneDistr, yIdx, (i, offPct, dimPct) => {\n    let laneOffPx = dim * offPct;\n    let laneWidPx = dim * dimPct;\n\n    draw(i, laneOffPx, laneWidPx);\n  });\n}\n\ninterface TimelineBoxRect extends Rect {\n  fillColor: string;\n}\n\n/**\n * @internal\n */\nexport interface TimelineCoreOptions {\n  mode: TimelineMode;\n  alignValue?: TimelineValueAlignment;\n  numSeries: number;\n  rowHeight?: number;\n  colWidth?: number;\n  theme: GrafanaTheme2;\n  showValue: VisibilityMode;\n  mergeValues?: boolean;\n  isDiscrete: (seriesIdx: number) => boolean;\n  hasMappedNull: (seriesIdx: number) => boolean;\n  getValueColor: (seriesIdx: number, value: unknown) => string;\n  label: (seriesIdx: number) => string;\n  getTimeRange: () => TimeRange;\n  formatValue?: (seriesIdx: number, value: unknown) => string;\n  getFieldConfig: (seriesIdx: number) => StateTimeLineFieldConfig | StatusHistoryFieldConfig;\n  hoverMulti: boolean;\n}\n\n/**\n * @internal\n */\nexport function getConfig(opts: TimelineCoreOptions) {\n  const {\n    mode,\n    numSeries,\n    isDiscrete,\n    hasMappedNull,\n    rowHeight = 0,\n    colWidth = 0,\n    showValue,\n    mergeValues = false,\n    theme,\n    label,\n    formatValue,\n    alignValue = 'left',\n    getTimeRange,\n    getValueColor,\n    getFieldConfig,\n    hoverMulti,\n  } = opts;\n\n  let qt: Quadtree;\n\n  // Needed for to calculate text positions\n  let boxRectsBySeries: TimelineBoxRect[][];\n\n  const resetBoxRectsBySeries = (count: number) => {\n    boxRectsBySeries = Array(numSeries)\n      .fill(null)\n      .map((v) => Array(count).fill(null));\n  };\n\n  const font = `500 ${Math.round(12 * devicePixelRatio)}px ${theme.typography.fontFamily}`;\n  const hovered: Array<Rect | null> = Array(numSeries).fill(null);\n  let hoveredAtCursor: Rect | null = null;\n\n  const size = [colWidth, Infinity];\n  const gapFactor = 1 - size[0];\n  const maxWidth = (size[1] ?? Infinity) * uPlot.pxRatio;\n\n  const fillPaths: Map<CanvasRenderingContext2D['fillStyle'], Path2D> = new Map();\n  const strokePaths: Map<CanvasRenderingContext2D['strokeStyle'], Path2D> = new Map();\n\n  function drawBoxes(ctx: CanvasRenderingContext2D) {\n    fillPaths.forEach((fillPath, fillStyle) => {\n      ctx.fillStyle = fillStyle;\n      ctx.fill(fillPath);\n    });\n\n    strokePaths.forEach((strokePath, strokeStyle) => {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke(strokePath);\n    });\n\n    fillPaths.clear();\n    strokePaths.clear();\n  }\n\n  function putBox(\n    ctx: CanvasRenderingContext2D,\n    rect: uPlot.RectH,\n    xOff: number,\n    yOff: number,\n    left: number,\n    top: number,\n    boxWidth: number,\n    boxHeight: number,\n    strokeWidth: number,\n    seriesIdx: number,\n    valueIdx: number,\n    value: number | null,\n    discrete: boolean\n  ) {\n    // clamp width to allow small boxes to be rendered\n    boxWidth = Math.max(1, boxWidth);\n\n    const valueColor = getValueColor(seriesIdx + 1, value);\n    const fieldConfig = getFieldConfig(seriesIdx);\n    const fillColor = getFillColor(fieldConfig, valueColor);\n\n    boxRectsBySeries[seriesIdx][valueIdx] = {\n      x: round(left - xOff),\n      y: round(top - yOff),\n      w: boxWidth,\n      h: boxHeight,\n      sidx: seriesIdx + 1,\n      didx: valueIdx,\n      // for computing label contrast\n      fillColor,\n    };\n\n    if (discrete) {\n      let fillStyle = fillColor;\n      let fillPath = fillPaths.get(fillStyle);\n\n      if (fillPath == null) {\n        fillPaths.set(fillStyle, (fillPath = new Path2D()));\n      }\n\n      rect(fillPath, left, top, boxWidth, boxHeight);\n\n      if (strokeWidth) {\n        let strokeStyle = valueColor;\n        let strokePath = strokePaths.get(strokeStyle);\n\n        if (strokePath == null) {\n          strokePaths.set(strokeStyle, (strokePath = new Path2D()));\n        }\n\n        rect(\n          strokePath,\n          left + strokeWidth / 2,\n          top + strokeWidth / 2,\n          boxWidth - strokeWidth,\n          boxHeight - strokeWidth\n        );\n      }\n    } else {\n      ctx.beginPath();\n      rect(ctx, left, top, boxWidth, boxHeight);\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n\n      if (strokeWidth) {\n        ctx.beginPath();\n        rect(ctx, left + strokeWidth / 2, top + strokeWidth / 2, boxWidth - strokeWidth, boxHeight - strokeWidth);\n        ctx.strokeStyle = valueColor;\n        ctx.lineWidth = strokeWidth;\n        ctx.stroke();\n      }\n    }\n  }\n\n  const drawPaths: Series.PathBuilder = (u, sidx, idx0, idx1) => {\n    uPlot.orient(\n      u,\n      sidx,\n      (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim, moveTo, lineTo, rect) => {\n        let strokeWidth = round((series.width || 0) * uPlot.pxRatio);\n\n        let discrete = isDiscrete(sidx);\n        let mappedNull = discrete && hasMappedNull(sidx);\n\n        u.ctx.save();\n        rect(u.ctx, u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n\n        walk(rowHeight, sidx - 1, numSeries, yDim, (iy, y0, height) => {\n          if (mode === TimelineMode.Changes) {\n            for (let ix = 0; ix < dataY.length; ix++) {\n              let yVal = dataY[ix];\n\n              if (yVal != null || mappedNull) {\n                let left = Math.round(valToPosX(dataX[ix], scaleX, xDim, xOff));\n\n                let nextIx = ix;\n                while (\n                  ++nextIx < dataY.length &&\n                  (dataY[nextIx] === undefined || (mergeValues && dataY[nextIx] === yVal))\n                ) {}\n\n                // to now (not to end of chart)\n                let right =\n                  nextIx === dataY.length\n                    ? xOff + xDim + strokeWidth\n                    : Math.round(valToPosX(dataX[nextIx], scaleX, xDim, xOff));\n\n                putBox(\n                  u.ctx,\n                  rect,\n                  xOff,\n                  yOff,\n                  left,\n                  round(yOff + y0),\n                  right - left,\n                  round(height),\n                  strokeWidth,\n                  iy,\n                  ix,\n                  yVal,\n                  discrete\n                );\n\n                ix = nextIx - 1;\n              }\n            }\n          } else if (mode === TimelineMode.Samples) {\n            let colWid = valToPosX(dataX[1], scaleX, xDim, xOff) - valToPosX(dataX[0], scaleX, xDim, xOff);\n            let gapWid = colWid * gapFactor;\n            let barWid = round(min(maxWidth, colWid - gapWid) - strokeWidth);\n            let xShift = barWid / 2;\n            //let xShift = align === 1 ? 0 : align === -1 ? barWid : barWid / 2;\n\n            for (let ix = idx0; ix <= idx1; ix++) {\n              let yVal = dataY[ix];\n\n              if (yVal != null || mappedNull) {\n                // TODO: all xPos can be pre-computed once for all series in aligned set\n                let left = valToPosX(dataX[ix], scaleX, xDim, xOff);\n\n                putBox(\n                  u.ctx,\n                  rect,\n                  xOff,\n                  yOff,\n                  round(left - xShift),\n                  round(yOff + y0),\n                  barWid,\n                  round(height),\n                  strokeWidth,\n                  iy,\n                  ix,\n                  yVal,\n                  discrete\n                );\n              }\n            }\n          }\n        });\n\n        if (discrete) {\n          u.ctx.lineWidth = strokeWidth;\n          drawBoxes(u.ctx);\n        }\n\n        u.ctx.restore();\n      }\n    );\n\n    return null;\n  };\n\n  const drawPoints: Series.Points.Show =\n    formatValue == null || showValue === VisibilityMode.Never\n      ? false\n      : (u, sidx, i0, i1) => {\n          u.ctx.save();\n          u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n          u.ctx.clip();\n\n          u.ctx.font = font;\n          u.ctx.textAlign = mode === TimelineMode.Changes ? alignValue : 'center';\n          u.ctx.textBaseline = 'middle';\n\n          uPlot.orient(\n            u,\n            sidx,\n            (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n              let strokeWidth = round((series.width || 0) * uPlot.pxRatio);\n\n              let discrete = isDiscrete(sidx);\n              let mappedNull = discrete && hasMappedNull(sidx);\n\n              let y = round(valToPosY(ySplits[sidx - 1], scaleY, yDim, yOff));\n\n              for (let ix = 0; ix < dataY.length; ix++) {\n                if (dataY[ix] != null || mappedNull) {\n                  const boxRect = boxRectsBySeries[sidx - 1][ix];\n\n                  if (!boxRect || boxRect.x >= xDim) {\n                    continue;\n                  }\n\n                  // if x placement is negative, rect is left truncated, remove it from width for calculating how many chars will display\n                  // right truncation happens automatically\n                  const displayedBoxWidth = boxRect.x < 0 ? boxRect?.w + boxRect.x : boxRect?.w;\n\n                  let maxChars = Math.floor(displayedBoxWidth / pxPerChar);\n\n                  if (showValue === VisibilityMode.Auto && maxChars < 2) {\n                    continue;\n                  }\n\n                  let txt = formatValue(sidx, dataY[ix]);\n\n                  // center-aligned\n                  let x = round(boxRect.x + xOff + boxRect.w / 2);\n                  if (mode === TimelineMode.Changes) {\n                    if (alignValue === 'left') {\n                      x = round(Math.max(boxRect.x, 0) + xOff + strokeWidth + textPadding);\n                    } else if (alignValue === 'right') {\n                      x = round(boxRect.x + xOff + boxRect.w - strokeWidth - textPadding);\n                    }\n                  }\n\n                  // TODO: cache by fillColor to avoid setting ctx for label\n                  u.ctx.fillStyle = theme.colors.getContrastText(boxRect.fillColor, 3);\n                  u.ctx.fillText(txt.slice(0, maxChars), x, y);\n                }\n              }\n            }\n          );\n\n          u.ctx.restore();\n\n          return false;\n        };\n\n  const init = (u: uPlot) => {\n    let chars = '';\n    for (let i = 32; i <= 126; i++) {\n      chars += String.fromCharCode(i);\n    }\n    pxPerChar = Math.ceil((u.ctx.measureText(chars).width / chars.length) * uPlot.pxRatio);\n\n    // be a bit more conservtive to prevent overlap\n    pxPerChar += 2.5;\n\n    u.root.querySelectorAll<HTMLDivElement>('.u-cursor-pt').forEach((el) => {\n      el.style.borderRadius = '0';\n    });\n  };\n\n  const drawClear = (u: uPlot) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n    resetBoxRectsBySeries(u.data[0].length);\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s) => {\n      // @ts-ignore\n      s._paths = null;\n    });\n  };\n\n  function setHovered(cx: number, cy: number, viaSync = false) {\n    hovered.fill(null);\n    hoveredAtCursor = null;\n\n    if (cx < 0) {\n      return;\n    }\n\n    // first gets all items in all quads intersected by a 1px wide by 10k high rect at the x cursor position and 0 y position.\n    // (we use 10k instead of plot area height for simplicity and not having to pass around the uPlot instance)\n    qt.get(cx, 0, uPlot.pxRatio, 1e4, (o) => {\n      // filter only rects that intersect along x dir\n      if (cx >= o.x && cx <= o.x + o.w) {\n        // if also intersect along y dir, set both \"direct hovered\" and \"one-of hovered\"\n        if (cy >= o.y && cy <= o.y + o.h) {\n          hovered[o.sidx] = hoveredAtCursor = o;\n        }\n        // else only set \"one-of hovered\" (no \"direct hovered\") in multi mode or when synced\n        else if (hoverMulti || viaSync) {\n          hovered[o.sidx] = o;\n        }\n      }\n    });\n  }\n\n  const cursor: uPlot.Cursor = {\n    x: mode === TimelineMode.Changes,\n    y: false,\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        // if quadtree is empty, fill it\n        if (qt.o.length === 0 && qt.q == null) {\n          for (const seriesRects of boxRectsBySeries) {\n            for (const rect of seriesRects) {\n              rect && qt.add(rect);\n            }\n          }\n        }\n\n        let cx = u.cursor.left! * uPlot.pxRatio;\n        let cy = u.cursor.top! * uPlot.pxRatio;\n\n        setHovered(cx, cy, u.cursor.event == null);\n      }\n\n      return hovered[seriesIdx]?.didx;\n    },\n    focus: {\n      prox: 1e3,\n      dist: (u, seriesIdx) => (hoveredAtCursor?.sidx === seriesIdx ? 0 : Infinity),\n    },\n    points: {\n      fill: 'rgba(255,255,255,0.2)',\n      bbox: (u, seriesIdx) => {\n        let hRect = hovered[seriesIdx];\n        let isHovered = hRect != null;\n\n        return {\n          left: isHovered ? hRect!.x / uPlot.pxRatio : -10,\n          top: isHovered ? hRect!.y / uPlot.pxRatio : -10,\n          width: isHovered ? hRect!.w / uPlot.pxRatio : 0,\n          height: isHovered ? hRect!.h / uPlot.pxRatio : 0,\n        };\n      },\n    },\n  };\n\n  const ySplits: number[] = Array(numSeries).fill(0);\n  const yRange: uPlot.Range.MinMax = [0, 1];\n\n  return {\n    cursor,\n\n    xSplits:\n      mode === TimelineMode.Samples\n        ? (u: uPlot, axisIdx: number, scaleMin: number, scaleMax: number, foundIncr: number, foundSpace: number) => {\n            let splits = [];\n\n            let dataIncr = u.data[0][1] - u.data[0][0];\n            let skipFactor = ceil(foundIncr / dataIncr);\n\n            for (let i = 0; i < u.data[0].length; i += skipFactor) {\n              let v = u.data[0][i];\n\n              if (v >= scaleMin && v <= scaleMax) {\n                splits.push(v);\n              }\n            }\n\n            return splits;\n          }\n        : null,\n\n    xRange: (u: uPlot) => {\n      const r = getTimeRange();\n\n      let min = r.from.valueOf();\n      let max = r.to.valueOf();\n\n      if (mode === TimelineMode.Samples) {\n        let colWid = u.data[0][1] - u.data[0][0];\n        let scalePad = colWid / 2;\n\n        if (min <= u.data[0][0]) {\n          min = u.data[0][0] - scalePad;\n        }\n\n        let lastIdx = u.data[0].length - 1;\n\n        if (max >= u.data[0][lastIdx]) {\n          max = u.data[0][lastIdx] + scalePad;\n        }\n      }\n\n      const result: uPlot.Range.MinMax = [min, max];\n      return result;\n    },\n\n    ySplits: (u: uPlot) => {\n      walk(rowHeight, null, numSeries, u.bbox.height, (iy, y0, hgt) => {\n        // vertical midpoints of each series' timeline (stored relative to .u-over)\n        let yMid = round(y0 + hgt / 2);\n        ySplits[iy] = u.posToVal(yMid / uPlot.pxRatio, FIXED_UNIT);\n      });\n\n      return ySplits;\n    },\n\n    yValues: (u: uPlot, splits: number[]) => splits.map((v, i) => label(i + 1)),\n    yRange,\n\n    // pathbuilders\n    drawPaths,\n    drawPoints,\n\n    // hooks\n    init,\n    drawClear,\n  };\n}\n\nfunction getFillColor(fieldConfig: { fillOpacity?: number; lineWidth?: number }, color: string) {\n  // if #rgba with pre-existing alpha. ignore fieldConfig.fillOpacity\n  // e.g. thresholds with opacity\n  if (color[0] === '#' && color.length === 9) {\n    return color;\n  }\n\n  const opacityPercent = (fieldConfig.fillOpacity ?? 100) / 100;\n  return colorManipulator.alpha(color, opacityPercent);\n}\n","import {\n  DataFrame,\n  FALLBACK_COLOR,\n  Field,\n  FieldColorModeId,\n  FieldConfig,\n  FieldType,\n  formattedValueToString,\n  getFieldDisplayName,\n  getValueFormat,\n  GrafanaTheme2,\n  getActiveThreshold,\n  Threshold,\n  getFieldConfigWithMinMax,\n  ThresholdsMode,\n  TimeRange,\n  cacheFieldDisplayNames,\n  outerJoinDataFrames,\n  ValueMapping,\n  ThresholdsConfig,\n  applyNullInsertThreshold,\n  nullToValue,\n} from '@grafana/data';\nimport { maybeSortFrame, NULL_RETAIN } from '@grafana/data/internal';\nimport {\n  VizLegendOptions,\n  AxisPlacement,\n  ScaleDirection,\n  ScaleOrientation,\n  VisibilityMode,\n  TimelineValueAlignment,\n  HideableFieldConfig,\n  MappingType,\n} from '@grafana/schema';\nimport { FIXED_UNIT, UPlotConfigBuilder, UPlotConfigPrepFn, VizLegendItem } from '@grafana/ui';\nimport { preparePlotData2, getStackingGroups } from '@grafana/ui/internal';\n\nimport { getConfig, TimelineCoreOptions } from './timeline';\n\n/**\n * @internal\n */\ninterface UPlotConfigOptions {\n  frame: DataFrame;\n  theme: GrafanaTheme2;\n  mode: TimelineMode;\n  rowHeight?: number;\n  colWidth?: number;\n  showValue: VisibilityMode;\n  alignValue?: TimelineValueAlignment;\n  mergeValues?: boolean;\n  getValueColor: (frameIdx: number, fieldIdx: number, value: unknown) => string;\n  hoverMulti: boolean;\n  axisWidth?: number;\n}\n\n/**\n * @internal\n */\ninterface PanelFieldConfig extends HideableFieldConfig {\n  fillOpacity?: number;\n  lineWidth?: number;\n}\n\nexport enum TimelineMode {\n  Changes = 'changes',\n  Samples = 'samples',\n}\n\nconst defaultConfig: PanelFieldConfig = {\n  lineWidth: 0,\n  fillOpacity: 80,\n};\n\nexport const preparePlotConfigBuilder: UPlotConfigPrepFn<UPlotConfigOptions> = ({\n  frame,\n  theme,\n  timeZones,\n  getTimeRange,\n  mode,\n  rowHeight,\n  colWidth,\n  showValue,\n  alignValue,\n  mergeValues,\n  getValueColor,\n  hoverMulti,\n}) => {\n  const builder = new UPlotConfigBuilder(timeZones[0]);\n\n  const xScaleKey = 'x';\n\n  const isDiscrete = (field: Field) => {\n    const mode = field.config?.color?.mode;\n    return !(mode && field.display && mode.startsWith('continuous-'));\n  };\n\n  const hasMappedNull = (field: Field) => {\n    return (\n      field.config.mappings?.some(\n        (mapping) => mapping.type === MappingType.SpecialValue && mapping.options.match === 'null'\n      ) || false\n    );\n  };\n\n  const getValueColorFn = (seriesIdx: number, value: unknown) => {\n    const field = frame.fields[seriesIdx];\n\n    if (\n      field.state?.origin?.fieldIndex !== undefined &&\n      field.state?.origin?.frameIndex !== undefined &&\n      getValueColor\n    ) {\n      return getValueColor(field.state?.origin?.frameIndex, field.state?.origin?.fieldIndex, value);\n    }\n\n    return FALLBACK_COLOR;\n  };\n\n  const opts: TimelineCoreOptions = {\n    mode: mode!,\n    numSeries: frame.fields.length - 1,\n    isDiscrete: (seriesIdx) => isDiscrete(frame.fields[seriesIdx]),\n    hasMappedNull: (seriesIdx) => hasMappedNull(frame.fields[seriesIdx]),\n    mergeValues,\n    rowHeight: rowHeight,\n    colWidth: colWidth,\n    showValue: showValue!,\n    alignValue,\n    theme,\n    label: (seriesIdx) => getFieldDisplayName(frame.fields[seriesIdx], frame),\n    getFieldConfig: (seriesIdx) => frame.fields[seriesIdx].config.custom,\n    getValueColor: getValueColorFn,\n    getTimeRange,\n    // hardcoded formatter for state values\n    formatValue: (seriesIdx, value) => formattedValueToString(frame.fields[seriesIdx].display!(value)),\n    hoverMulti,\n  };\n\n  const coreConfig = getConfig(opts);\n\n  builder.addHook('init', coreConfig.init);\n  builder.addHook('drawClear', coreConfig.drawClear);\n\n  builder.setPrepData((frames) => preparePlotData2(frames[0], getStackingGroups(frames[0])));\n\n  builder.setCursor(coreConfig.cursor);\n\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime: true,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: coreConfig.xRange,\n  });\n\n  builder.addScale({\n    scaleKey: FIXED_UNIT, // y\n    isTime: false,\n    orientation: ScaleOrientation.Vertical,\n    direction: ScaleDirection.Up,\n    range: coreConfig.yRange,\n  });\n\n  const xAxisHidden = frame.fields[0].config.custom.axisPlacement === AxisPlacement.Hidden;\n\n  builder.addAxis({\n    show: !xAxisHidden,\n    scaleKey: xScaleKey,\n    isTime: true,\n    splits: coreConfig.xSplits!,\n    placement: AxisPlacement.Bottom,\n    timeZone: timeZones[0],\n    theme,\n  });\n\n  const yCustomConfig = frame.fields[1].config.custom;\n  const yAxisWidth = yCustomConfig.axisWidth;\n  const yAxisHidden = yCustomConfig.axisPlacement === AxisPlacement.Hidden;\n\n  builder.addAxis({\n    scaleKey: FIXED_UNIT, // y\n    isTime: false,\n    placement: AxisPlacement.Left,\n    splits: coreConfig.ySplits,\n    values: yAxisHidden ? (u, splits) => splits.map((v) => null) : coreConfig.yValues,\n    grid: { show: false },\n    ticks: { show: false },\n    gap: yAxisHidden ? 0 : 16,\n    size: yAxisHidden ? 0 : yAxisWidth,\n    theme,\n  });\n\n  let seriesIndex = 0;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    if (i === 0) {\n      continue;\n    }\n\n    const field = frame.fields[i];\n    const config: FieldConfig<PanelFieldConfig> = field.config;\n    const customConfig: PanelFieldConfig = {\n      ...defaultConfig,\n      ...config.custom,\n    };\n\n    field.state!.seriesIndex = seriesIndex++;\n\n    // const scaleKey = config.unit || FIXED_UNIT;\n    // const colorMode = getFieldColorModeForField(field);\n\n    builder.addSeries({\n      scaleKey: FIXED_UNIT,\n      pathBuilder: coreConfig.drawPaths,\n      pointsBuilder: coreConfig.drawPoints,\n      //colorMode,\n      lineWidth: customConfig.lineWidth,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      show: !customConfig.hideFrom?.viz,\n      thresholds: config.thresholds,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: field.state?.origin,\n    });\n  }\n\n  return builder;\n};\n\nfunction getSpanNulls(field: Field) {\n  let spanNulls = field.config.custom?.spanNulls;\n\n  // magic value for join() to leave nulls alone instead of expanding null ranges\n  // should be set to -1 when spanNulls = null|undefined|false|0, which is \"retain nulls, without expanding\"\n  // Infinity is not optimal here since it causes spanNulls to be more expensive than simply removing all nulls unconditionally\n  return !spanNulls ? -1 : spanNulls === true ? Infinity : spanNulls;\n}\n\n/**\n * Merge values by the threshold\n */\nexport function mergeThresholdValues(field: Field, theme: GrafanaTheme2): Field | undefined {\n  const thresholds = field.config.thresholds;\n  if (field.type !== FieldType.number || !thresholds || !thresholds.steps.length) {\n    return undefined;\n  }\n\n  const items = getThresholdItems(field.config, theme);\n  if (items.length !== thresholds.steps.length) {\n    return undefined; // should not happen\n  }\n\n  const thresholdToText = new Map<Threshold, string>();\n  const textToColor = new Map<string, string>();\n  for (let i = 0; i < items.length; i++) {\n    thresholdToText.set(thresholds.steps[i], items[i].label);\n    textToColor.set(items[i].label, items[i].color!);\n  }\n\n  let input = field.values;\n  const vals = new Array<String | undefined>(field.values.length);\n  if (thresholds.mode === ThresholdsMode.Percentage) {\n    const { min, max } = getFieldConfigWithMinMax(field);\n    const delta = max! - min!;\n    input = input.map((v) => {\n      if (v == null) {\n        return v;\n      }\n      return ((v - min!) / delta) * 100;\n    });\n  }\n\n  for (let i = 0; i < vals.length; i++) {\n    const v = input[i];\n    if (v == null) {\n      vals[i] = v;\n    } else {\n      vals[i] = thresholdToText.get(getActiveThreshold(v, thresholds.steps));\n    }\n  }\n\n  return {\n    ...field,\n    config: {\n      ...field.config,\n      custom: {\n        ...field.config.custom,\n        spanNulls: getSpanNulls(field),\n      },\n    },\n    type: FieldType.string,\n    values: vals,\n    display: (value) => ({\n      text: String(value),\n      color: textToColor.get(String(value)),\n      numeric: NaN,\n    }),\n  };\n}\n\n// This will return a set of frames with only graphable values included\nexport function prepareTimelineFields(\n  series: DataFrame[] | undefined,\n  mergeValues: boolean,\n  timeRange: TimeRange,\n  theme: GrafanaTheme2\n): { frames?: DataFrame[]; warn?: string } {\n  if (!series?.length) {\n    return { warn: 'No data in response' };\n  }\n\n  cacheFieldDisplayNames(series);\n\n  let hasTimeseries = false;\n  const frames: DataFrame[] = [];\n\n  for (let frame of series) {\n    let startFieldIdx = -1;\n    let endFieldIdx = -1;\n\n    for (let i = 0; i < frame.fields.length; i++) {\n      let f = frame.fields[i];\n\n      if (f.type === FieldType.time) {\n        if (startFieldIdx === -1) {\n          startFieldIdx = i;\n        } else if (endFieldIdx === -1) {\n          endFieldIdx = i;\n          break;\n        }\n      }\n    }\n\n    let isTimeseries = startFieldIdx !== -1;\n    let changed = false;\n    frame = maybeSortFrame(frame, startFieldIdx);\n\n    // if we have a second time field, assume it is state end timestamps\n    // and insert nulls into the data at the end timestamps\n    if (endFieldIdx !== -1) {\n      let startFrame: DataFrame = {\n        ...frame,\n        fields: frame.fields.filter((f, i) => i !== endFieldIdx),\n      };\n\n      let endFrame: DataFrame = {\n        length: frame.length,\n        fields: [frame.fields[endFieldIdx]],\n      };\n\n      frame = outerJoinDataFrames({\n        frames: [startFrame, endFrame],\n        keepDisplayNames: true,\n        nullMode: () => NULL_RETAIN,\n      })!;\n\n      frame.fields.forEach((f, i) => {\n        if (i > 0) {\n          let vals = f.values;\n          for (let i = 0; i < vals.length; i++) {\n            if (vals[i] == null) {\n              vals[i] = null;\n            }\n          }\n        }\n      });\n\n      changed = true;\n    }\n\n    let nulledFrame = applyNullInsertThreshold({\n      frame,\n      refFieldPseudoMin: timeRange.from.valueOf(),\n      refFieldPseudoMax: timeRange.to.valueOf(),\n    });\n\n    if (nulledFrame !== frame) {\n      changed = true;\n    }\n\n    frame = nullToValue(nulledFrame);\n\n    const fields: Field[] = [];\n    for (let field of frame.fields) {\n      switch (field.type) {\n        case FieldType.time:\n          isTimeseries = true;\n          hasTimeseries = true;\n          fields.push(field);\n          break;\n        case FieldType.enum:\n        case FieldType.number:\n          if (mergeValues && field.config.color?.mode === FieldColorModeId.Thresholds) {\n            const f = mergeThresholdValues(field, theme);\n            if (f) {\n              fields.push(f);\n              changed = true;\n              continue;\n            }\n          }\n\n        case FieldType.boolean:\n        case FieldType.string:\n          field = {\n            ...field,\n            config: {\n              ...field.config,\n              custom: {\n                ...field.config.custom,\n                spanNulls: getSpanNulls(field),\n              },\n            },\n          };\n          changed = true;\n          fields.push(field);\n          break;\n        default:\n          changed = true;\n      }\n    }\n    if (isTimeseries && fields.length > 1) {\n      hasTimeseries = true;\n      if (changed) {\n        frames.push({\n          ...frame,\n          fields,\n        });\n      } else {\n        frames.push(frame);\n      }\n    }\n  }\n\n  if (!hasTimeseries) {\n    return { warn: 'Data does not have a time field' };\n  }\n  if (!frames.length) {\n    return { warn: 'No graphable fields' };\n  }\n\n  return { frames };\n}\n\nexport function makeFramePerSeries(frames: DataFrame[]) {\n  const outFrames: DataFrame[] = [];\n\n  for (let frame of frames) {\n    const timeFields = frame.fields.filter((field) => field.type === FieldType.time);\n\n    if (timeFields.length > 0) {\n      for (let field of frame.fields) {\n        if (field.type !== FieldType.time) {\n          outFrames.push({ fields: [...timeFields, field], length: frame.length });\n        }\n      }\n    }\n  }\n\n  return outFrames;\n}\n\nexport function getThresholdItems(\n  fieldConfig: FieldConfig,\n  theme: GrafanaTheme2,\n  thresholdItems?: ThresholdsConfig\n): VizLegendItem[] {\n  const items: VizLegendItem[] = [];\n  const thresholds = thresholdItems ? thresholdItems : fieldConfig.thresholds;\n  if (!thresholds || !thresholds.steps.length) {\n    return items;\n  }\n\n  const steps = thresholds.steps;\n  const getDisplay = getValueFormat(\n    thresholds.mode === ThresholdsMode.Percentage ? 'percent' : (fieldConfig.unit ?? '')\n  );\n\n  // `undefined` value for decimals will use `auto`\n  const format = (value: number) => formattedValueToString(getDisplay(value, fieldConfig.decimals ?? undefined));\n\n  for (let i = 0; i < steps.length; i++) {\n    let step = steps[i];\n    let value = step.value;\n    let pre = '';\n    let suf = '';\n\n    if (value === -Infinity && i < steps.length - 1) {\n      value = steps[i + 1].value;\n      pre = '< ';\n    } else {\n      suf = '+';\n    }\n\n    items.push({\n      label: `${pre}${format(value)}${suf}`,\n      color: theme.visualization.getColorByName(step.color),\n      yAxis: 1,\n    });\n  }\n\n  return items;\n}\n\nexport function getValueMappingItems(mappings: ValueMapping[], theme: GrafanaTheme2): VizLegendItem[] {\n  const items: VizLegendItem[] = [];\n  if (!mappings) {\n    return items;\n  }\n\n  for (let mapping of mappings) {\n    const { options, type } = mapping;\n\n    if (type === MappingType.ValueToText) {\n      for (let [label, value] of Object.entries(options)) {\n        const color = value.color;\n        items.push({\n          label: label,\n          color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n          yAxis: 1,\n        });\n      }\n    }\n\n    if (type === MappingType.RangeToText) {\n      const { from, result, to } = options;\n      const { text, color } = result;\n      const label = text ? `[${from} - ${to}] ${text}` : `[${from} - ${to}]`;\n\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n\n    if (type === MappingType.RegexToText) {\n      const { pattern, result } = options;\n      const { text, color } = result;\n      const label = `${text || pattern}`;\n\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n\n    if (type === MappingType.SpecialValue) {\n      const { match, result } = options;\n      const { text, color } = result;\n      const label = `${text || match}`;\n\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n  }\n\n  return items;\n}\n\nexport function prepareTimelineLegendItems(\n  frames: DataFrame[] | undefined,\n  options: VizLegendOptions,\n  theme: GrafanaTheme2\n): VizLegendItem[] | undefined {\n  if (!frames || options.showLegend === false) {\n    return undefined;\n  }\n\n  return getFieldLegendItem(allNonTimeFields(frames), theme);\n}\n\nexport function getFieldLegendItem(fields: Field[], theme: GrafanaTheme2): VizLegendItem[] | undefined {\n  if (!fields.length) {\n    return undefined;\n  }\n\n  const items: VizLegendItem[] = [];\n  const fieldConfig = fields[0].config;\n  const colorMode = fieldConfig.color?.mode ?? FieldColorModeId.Fixed;\n  const thresholds = fieldConfig.thresholds;\n\n  // If thresholds are enabled show each step in the legend\n  // This ignores the hide from legend since the range is valid\n  if (colorMode === FieldColorModeId.Thresholds && thresholds?.steps && thresholds.steps.length > 1) {\n    return getThresholdItems(fieldConfig, theme);\n  }\n\n  // If thresholds are enabled show each step in the legend\n  if (colorMode.startsWith('continuous')) {\n    return undefined; // eventually a color bar\n  }\n\n  const stateColors: Map<string, string | undefined> = new Map();\n\n  fields.forEach((field) => {\n    if (!field.config.custom?.hideFrom?.legend) {\n      field.values.forEach((v) => {\n        let state = field.display!(v);\n        if (state.color) {\n          stateColors.set(state.text, state.color!);\n        }\n      });\n    }\n  });\n\n  stateColors.forEach((color, label) => {\n    if (label.length > 0) {\n      items.push({\n        label: label!,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n  });\n\n  return items;\n}\n\nfunction allNonTimeFields(frames: DataFrame[]): Field[] {\n  const fields: Field[] = [];\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.type !== FieldType.time) {\n        fields.push(field);\n      }\n    }\n  }\n  return fields;\n}\n\nexport function findNextStateIndex(field: Field, datapointIdx: number) {\n  let end;\n  let rightPointer = datapointIdx + 1;\n\n  if (rightPointer >= field.values.length) {\n    return null;\n  }\n\n  const startValue = field.values[datapointIdx];\n\n  while (end === undefined) {\n    if (rightPointer >= field.values.length) {\n      return null;\n    }\n    const rightValue = field.values[rightPointer];\n\n    if (rightValue === undefined || rightValue === startValue) {\n      rightPointer++;\n    } else {\n      end = rightPointer;\n    }\n  }\n\n  return end;\n}\n\n/**\n * Returns the precise duration of a time range passed in milliseconds.\n * This function calculates with 30 days month and 365 days year.\n * adapted from https://gist.github.com/remino/1563878\n * @param milliSeconds The duration in milliseconds\n * @returns A formated string of the duration\n */\nexport function fmtDuration(milliSeconds: number): string {\n  if (milliSeconds < 0 || Number.isNaN(milliSeconds)) {\n    return '';\n  }\n\n  let yr: number, mo: number, wk: number, d: number, h: number, m: number, s: number, ms: number;\n\n  s = Math.floor(milliSeconds / 1000);\n  m = Math.floor(s / 60);\n  s = s % 60;\n  h = Math.floor(m / 60);\n  m = m % 60;\n  d = Math.floor(h / 24);\n  h = h % 24;\n\n  yr = Math.floor(d / 365);\n  if (yr > 0) {\n    d = d % 365;\n  }\n\n  mo = Math.floor(d / 30);\n  if (mo > 0) {\n    d = d % 30;\n  }\n\n  wk = Math.floor(d / 7);\n\n  if (wk > 0) {\n    d = d % 7;\n  }\n\n  ms = Math.round((milliSeconds % 1000) * 1000) / 1000;\n\n  return (\n    yr > 0\n      ? yr + 'y ' + (mo > 0 ? mo + 'mo ' : '') + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '')\n      : mo > 0\n        ? mo + 'mo ' + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '')\n        : wk > 0\n          ? wk + 'w ' + (d > 0 ? d + 'd ' : '')\n          : d > 0\n            ? d + 'd ' + (h > 0 ? h + 'h ' : '')\n            : h > 0\n              ? h + 'h ' + (m > 0 ? m + 'm ' : '')\n              : m > 0\n                ? m + 'm ' + (s > 0 ? s + 's ' : '')\n                : s > 0\n                  ? s + 's ' + (ms > 0 ? ms + 'ms ' : '')\n                  : ms > 0\n                    ? ms + 'ms '\n                    : '0'\n  ).trim();\n}\n","import { roundDecimals } from '@grafana/data';\n\nexport const SPACE_BETWEEN = 1;\nexport const SPACE_AROUND = 2;\nexport const SPACE_EVENLY = 3;\n\nconst coord = (i: number, offs: number, iwid: number, gap: number) => roundDecimals(offs + i * (iwid + gap), 6);\n\nexport type Each = (idx: number, offPct: number, dimPct: number) => void;\n\n/**\n * @internal\n */\nexport function distribute(numItems: number, sizeFactor: number, justify: number, onlyIdx: number | null, each: Each) {\n  let space = 1 - sizeFactor;\n\n  /* eslint-disable no-multi-spaces */\n  // prettier-ignore\n  let gap = (\n    justify === SPACE_BETWEEN ? space / (numItems - 1) :\n    justify === SPACE_AROUND  ? space / (numItems  )   :\n    justify === SPACE_EVENLY  ? space / (numItems + 1) : 0\n  );\n\n  if (isNaN(gap) || gap === Infinity) {\n    gap = 0;\n  }\n\n  // prettier-ignore\n  let offs = (\n    justify === SPACE_BETWEEN ? 0       :\n    justify === SPACE_AROUND  ? gap / 2 :\n    justify === SPACE_EVENLY  ? gap     : 0\n  );\n  /* eslint-enable */\n\n  let iwid = sizeFactor / numItems;\n  let _iwid = roundDecimals(iwid, 6);\n\n  if (onlyIdx == null) {\n    for (let i = 0; i < numItems; i++) {\n      each(i, coord(i, offs, iwid, gap), _iwid);\n    }\n  } else {\n    each(onlyIdx, coord(onlyIdx, offs, iwid, gap), _iwid);\n  }\n}\n","const MAX_OBJECTS = 10;\nconst MAX_LEVELS = 4;\n\nexport type Quads = [Quadtree, Quadtree, Quadtree, Quadtree];\nexport type Rect = { x: number; y: number; w: number; h: number; [_: string]: any };\n\n/**\n * @internal\n */\nexport function pointWithin(px: number, py: number, rlft: number, rtop: number, rrgt: number, rbtm: number) {\n  return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;\n}\n\n/**\n * @internal\n */\nexport function findRects(qt: Quadtree, sidx?: number, didx?: number) {\n  let rects: Rect[] = [];\n\n  if (qt.o.length) {\n    rects.push(...qt.o.filter((rect) => (sidx == null || rect.sidx === sidx) && (didx == null || rect.didx === didx)));\n  }\n\n  if (qt.q) {\n    for (let i = 0; i < qt.q.length; i++) {\n      rects.push(...findRects(qt.q[i], sidx, didx));\n    }\n  }\n\n  return rects;\n}\n\n/**\n * @internal\n *\n * Determines if r2 is intersected by r1.\n */\nexport function intersects(r1: Rect, r2: Rect) {\n  return r1.x <= r2.x + r2.w && r1.x + r1.w >= r2.x && r1.y + r1.h >= r2.y && r1.y <= r2.y + r2.h;\n}\n\n/**\n * @internal\n */\nexport class Quadtree {\n  o: Rect[];\n  q: Quads | null;\n\n  constructor(\n    public x: number,\n    public y: number,\n    public w: number,\n    public h: number,\n    public l = 0\n  ) {\n    this.o = [];\n    this.q = null;\n  }\n\n  split() {\n    let t = this,\n      x = t.x,\n      y = t.y,\n      w = t.w / 2,\n      h = t.h / 2,\n      l = t.l + 1;\n\n    t.q = [\n      // top right\n      new Quadtree(x + w, y, w, h, l),\n      // top left\n      new Quadtree(x, y, w, h, l),\n      // bottom left\n      new Quadtree(x, y + h, w, h, l),\n      // bottom right\n      new Quadtree(x + w, y + h, w, h, l),\n    ];\n  }\n\n  // invokes callback with index of each overlapping quad\n  quads(x: number, y: number, w: number, h: number, cb: (q: Quadtree) => void) {\n    let t = this,\n      q = t.q!,\n      hzMid = t.x + t.w / 2,\n      vtMid = t.y + t.h / 2,\n      startIsNorth = y < vtMid,\n      startIsWest = x < hzMid,\n      endIsEast = x + w > hzMid,\n      endIsSouth = y + h > vtMid;\n\n    // top-right quad\n    startIsNorth && endIsEast && cb(q[0]);\n    // top-left quad\n    startIsWest && startIsNorth && cb(q[1]);\n    // bottom-left quad\n    startIsWest && endIsSouth && cb(q[2]);\n    // bottom-right quad\n    endIsEast && endIsSouth && cb(q[3]);\n  }\n\n  add(o: Rect) {\n    let t = this;\n\n    if (t.q != null) {\n      t.quads(o.x, o.y, o.w, o.h, (q) => {\n        q.add(o);\n      });\n    } else {\n      let os = t.o;\n\n      os.push(o);\n\n      if (os.length > MAX_OBJECTS && t.l < MAX_LEVELS) {\n        t.split();\n\n        for (let i = 0; i < os.length; i++) {\n          let oi = os[i];\n\n          t.quads(oi.x, oi.y, oi.w, oi.h, (q) => {\n            q.add(oi);\n          });\n        }\n\n        t.o.length = 0;\n      }\n    }\n  }\n\n  get(x: number, y: number, w: number, h: number, cb: (o: Rect) => void) {\n    let t = this;\n    let os = t.o;\n\n    for (let i = 0; i < os.length; i++) {\n      cb(os[i]);\n    }\n\n    if (t.q != null) {\n      t.quads(x, y, w, h, (q) => {\n        q.get(x, y, w, h, cb);\n      });\n    }\n  }\n\n  clear() {\n    this.o.length = 0;\n    this.q = null;\n  }\n}\n"],"names":["round","min","ceil","textPadding","pxPerChar","laneDistr","walk","rowHeight","yIdx","count","dim","draw","distribute","i","offPct","dimPct","laneOffPx","laneWidPx","getConfig","opts","mode","numSeries","isDiscrete","hasMappedNull","colWidth","showValue","mergeValues","theme","label","formatValue","alignValue","getTimeRange","getValueColor","getFieldConfig","hoverMulti","qt","boxRectsBySeries","resetBoxRectsBySeries","v","font","hovered","hoveredAtCursor","size","gapFactor","maxWidth","fillPaths","strokePaths","drawBoxes","ctx","fillPath","fillStyle","strokePath","strokeStyle","putBox","rect","xOff","yOff","left","top","boxWidth","boxHeight","strokeWidth","seriesIdx","valueIdx","value","discrete","valueColor","fieldConfig","fillColor","getFillColor","drawPaths","u","sidx","idx0","idx1","series","dataX","dataY","scaleX","scaleY","valToPosX","valToPosY","xDim","yDim","moveTo","lineTo","mappedNull","iy","y0","height","TimelineMode","ix","yVal","nextIx","right","colWid","gapWid","barWid","xShift","drawPoints","i0","i1","y","ySplits","boxRect","displayedBoxWidth","maxChars","txt","x","init","chars","el","drawClear","s","setHovered","cx","cy","viaSync","o","cursor","seriesRects","hRect","isHovered","yRange","axisIdx","scaleMin","scaleMax","foundIncr","foundSpace","splits","dataIncr","skipFactor","max","scalePad","lastIdx","hgt","yMid","color","opacityPercent","colorManipulator","defaultConfig","preparePlotConfigBuilder","frame","timeZones","builder","UPlotConfigBuilder","xScaleKey","field","mapping","getValueColorFn","coreConfig","frames","xAxisHidden","yCustomConfig","yAxisWidth","yAxisHidden","seriesIndex","config","customConfig","getSpanNulls","spanNulls","mergeThresholdValues","thresholds","items","getThresholdItems","thresholdToText","textToColor","input","vals","delta","prepareTimelineFields","timeRange","hasTimeseries","startFieldIdx","endFieldIdx","isTimeseries","changed","startFrame","f","endFrame","nulledFrame","nullToValue","fields","makeFramePerSeries","outFrames","timeFields","thresholdItems","steps","getDisplay","format","step","pre","suf","getValueMappingItems","mappings","options","type","from","result","to","text","pattern","match","prepareTimelineLegendItems","getFieldLegendItem","allNonTimeFields","colorMode","stateColors","state","findNextStateIndex","datapointIdx","end","rightPointer","startValue","rightValue","fmtDuration","milliSeconds","yr","mo","wk","d","h","m","ms","SPACE_BETWEEN","SPACE_AROUND","SPACE_EVENLY","coord","offs","iwid","gap","numItems","sizeFactor","justify","onlyIdx","each","space","_iwid","MAX_OBJECTS","MAX_LEVELS","pointWithin","px","py","rlft","rtop","rrgt","rbtm","findRects","didx","rects","intersects","r1","r2","Quadtree","w","l","t","cb","q","hzMid","vtMid","startIsNorth","startIsWest","endIsEast","endIsSouth","os","oi"],"sourceRoot":""}