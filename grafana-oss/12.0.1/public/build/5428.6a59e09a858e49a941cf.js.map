{"version":3,"file":"5428.6a59e09a858e49a941cf.js","mappings":"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","sources":["webpack://grafana/./public/app/core/components/GraphNG/GraphNG.tsx","webpack://grafana/./packages/grafana-data/src/transformations/transformers/nulls/nullToUndefThreshold.ts","webpack://grafana/./public/app/core/components/GraphNG/utils.ts","webpack://grafana/./public/app/core/components/TimeSeries/utils.ts","webpack://grafana/./public/app/core/components/TimeSeries/TimeSeries.tsx","webpack://grafana/./public/app/plugins/panel/timeseries/TimeSeriesTooltip.tsx","webpack://grafana/./public/app/plugins/panel/xychart/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/xychart/utils.ts"],"sourcesContent":["import { Component } from 'react';\nimport * as React from 'react';\nimport uPlot, { AlignedData } from 'uplot';\n\nimport {\n  DataFrame,\n  DataLinkPostProcessor,\n  Field,\n  FieldMatcherID,\n  fieldMatchers,\n  FieldType,\n  getLinksSupplier,\n  InterpolateFunction,\n  TimeRange,\n  TimeZone,\n} from '@grafana/data';\nimport { DashboardCursorSync, VizLegendOptions } from '@grafana/schema';\nimport { Themeable2, VizLayout } from '@grafana/ui';\nimport { UPlotChart, AxisProps, Renderers, UPlotConfigBuilder, ScaleProps, pluginLog } from '@grafana/ui/internal';\n\nimport { GraphNGLegendEvent, XYFieldMatchers } from './types';\nimport { preparePlotFrame as defaultPreparePlotFrame } from './utils';\n\n/**\n * @internal -- not a public API\n */\nexport type PropDiffFn<T extends Record<string, unknown> = {}> = (prev: T, next: T) => boolean;\n\nexport interface GraphNGProps extends Themeable2 {\n  frames: DataFrame[];\n  structureRev?: number; // a number that will change when the frames[] structure changes\n  width: number;\n  height: number;\n  timeRange: TimeRange;\n  timeZone: TimeZone[] | TimeZone;\n  legend: VizLegendOptions;\n  fields?: XYFieldMatchers; // default will assume timeseries data\n  renderers?: Renderers;\n  tweakScale?: (opts: ScaleProps, forField: Field) => ScaleProps;\n  tweakAxis?: (opts: AxisProps, forField: Field) => AxisProps;\n  onLegendClick?: (event: GraphNGLegendEvent) => void;\n  children?: (builder: UPlotConfigBuilder, alignedFrame: DataFrame) => React.ReactNode;\n  prepConfig: (alignedFrame: DataFrame, allFrames: DataFrame[], getTimeRange: () => TimeRange) => UPlotConfigBuilder;\n  propsToDiff?: Array<string | PropDiffFn>;\n  preparePlotFrame?: (frames: DataFrame[], dimFields: XYFieldMatchers) => DataFrame | null;\n  renderLegend: (config: UPlotConfigBuilder) => React.ReactElement | null;\n  replaceVariables: InterpolateFunction;\n  dataLinkPostProcessor?: DataLinkPostProcessor;\n  cursorSync?: DashboardCursorSync;\n\n  // Remove fields that are hidden from the visualization before rendering\n  // The fields will still be available for other things like data links\n  // this is a temporary hack that only works when:\n  // 1. renderLegend (above) does not render <PlotLegend>\n  // 2. does not have legend series toggle\n  // 3. passes through all fields required for link/action gen (including those with hideFrom.viz)\n  omitHideFromViz?: boolean;\n\n  /**\n   * needed for propsToDiff to re-init the plot & config\n   * this is a generic approach to plot re-init, without having to specify which panel-level options\n   * should cause invalidation. we can drop this in favor of something like panelOptionsRev that gets passed in\n   * similar to structureRev. then we can drop propsToDiff entirely.\n   */\n  options?: Record<string, any>;\n}\n\nfunction sameProps<T extends Record<string, unknown>>(\n  prevProps: T,\n  nextProps: T,\n  propsToDiff: Array<string | PropDiffFn> = []\n) {\n  for (const propName of propsToDiff) {\n    if (typeof propName === 'function') {\n      if (!propName(prevProps, nextProps)) {\n        return false;\n      }\n    } else if (nextProps[propName] !== prevProps[propName]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @internal -- not a public API\n */\nexport interface GraphNGState {\n  alignedFrame: DataFrame;\n  alignedData?: AlignedData;\n  config?: UPlotConfigBuilder;\n}\n\nconst defaultMatchers = {\n  x: fieldMatchers.get(FieldMatcherID.firstTimeField).get({}),\n  y: fieldMatchers.get(FieldMatcherID.byTypes).get(new Set([FieldType.number, FieldType.enum])),\n};\n\n/**\n * \"Time as X\" core component, expects ascending x\n */\nexport class GraphNG extends Component<GraphNGProps, GraphNGState> {\n  private plotInstance: React.RefObject<uPlot>;\n\n  constructor(props: GraphNGProps) {\n    super(props);\n    let state = this.prepState(props);\n    state.alignedData = state.config!.prepData!([state.alignedFrame]) as AlignedData;\n    this.state = state;\n    this.plotInstance = React.createRef();\n  }\n\n  getTimeRange = () => this.props.timeRange;\n\n  prepState(props: GraphNGProps, withConfig = true) {\n    let state: GraphNGState = null as any;\n\n    const { frames, fields = defaultMatchers, preparePlotFrame, replaceVariables, dataLinkPostProcessor } = props;\n\n    const preparePlotFrameFn = preparePlotFrame ?? defaultPreparePlotFrame;\n\n    const withLinks = frames.some((frame) => frame.fields.some((field) => (field.config.links?.length ?? 0) > 0));\n\n    const alignedFrame = preparePlotFrameFn(\n      frames,\n      {\n        ...fields,\n        // if there are data links, keep all fields during join so they're index-matched\n        y: withLinks ? () => true : fields.y,\n      },\n      props.timeRange\n    );\n\n    pluginLog('GraphNG', false, 'data aligned', alignedFrame);\n\n    if (alignedFrame) {\n      let alignedFrameFinal = alignedFrame;\n\n      if (withLinks) {\n        const timeZone = Array.isArray(this.props.timeZone) ? this.props.timeZone[0] : this.props.timeZone;\n\n        // for links gen we need to use original frames but with the aligned/joined data values\n        let linkFrames = frames.map((frame, frameIdx) => ({\n          ...frame,\n          fields: alignedFrame.fields.filter(\n            (field, fieldIdx) => fieldIdx === 0 || field.state?.origin?.frameIndex === frameIdx\n          ),\n          length: alignedFrame.length,\n        }));\n\n        linkFrames.forEach((linkFrame, frameIndex) => {\n          linkFrame.fields.forEach((field) => {\n            field.getLinks = getLinksSupplier(\n              linkFrame,\n              field,\n              {\n                ...field.state?.scopedVars,\n                __dataContext: {\n                  value: {\n                    data: linkFrames,\n                    field: field,\n                    frame: linkFrame,\n                    frameIndex,\n                  },\n                },\n              },\n              replaceVariables,\n              timeZone,\n              dataLinkPostProcessor\n            );\n          });\n        });\n\n        // filter join field and fields.y\n        alignedFrameFinal = {\n          ...alignedFrame,\n          fields: alignedFrame.fields.filter((field, i) => i === 0 || fields.y(field, alignedFrame, [alignedFrame])),\n        };\n      }\n\n      if (props.omitHideFromViz) {\n        const nonHiddenFields = alignedFrameFinal.fields.filter((field) => field.config.custom?.hideFrom?.viz !== true);\n        alignedFrameFinal = {\n          ...alignedFrameFinal,\n          fields: nonHiddenFields,\n          length: nonHiddenFields.length,\n        };\n      }\n\n      let config = this.state?.config;\n\n      if (withConfig) {\n        config = props.prepConfig(alignedFrameFinal, this.props.frames, this.getTimeRange);\n        pluginLog('GraphNG', false, 'config prepared', config);\n      }\n\n      state = {\n        alignedFrame: alignedFrameFinal,\n        config,\n      };\n\n      pluginLog('GraphNG', false, 'data prepared', state.alignedData);\n    }\n\n    return state;\n  }\n\n  componentDidUpdate(prevProps: GraphNGProps) {\n    const { frames, structureRev, timeZone, cursorSync, propsToDiff } = this.props;\n\n    const propsChanged = !sameProps(prevProps, this.props, propsToDiff);\n\n    if (\n      frames !== prevProps.frames ||\n      propsChanged ||\n      timeZone !== prevProps.timeZone ||\n      cursorSync !== prevProps.cursorSync\n    ) {\n      let newState = this.prepState(this.props, false);\n\n      if (newState) {\n        const shouldReconfig =\n          this.state.config === undefined ||\n          timeZone !== prevProps.timeZone ||\n          cursorSync !== prevProps.cursorSync ||\n          structureRev !== prevProps.structureRev ||\n          !structureRev ||\n          propsChanged;\n\n        if (shouldReconfig) {\n          newState.config = this.props.prepConfig(newState.alignedFrame, this.props.frames, this.getTimeRange);\n          pluginLog('GraphNG', false, 'config recreated', newState.config);\n        }\n\n        newState.alignedData = newState.config!.prepData!([newState.alignedFrame]) as AlignedData;\n\n        this.setState(newState);\n      }\n    }\n  }\n\n  render() {\n    const { width, height, children, renderLegend } = this.props;\n    const { config, alignedFrame, alignedData } = this.state;\n\n    if (!config) {\n      return null;\n    }\n\n    return (\n      <VizLayout width={width} height={height} legend={renderLegend(config)}>\n        {(vizWidth: number, vizHeight: number) => (\n          <UPlotChart\n            config={config}\n            data={alignedData!}\n            width={vizWidth}\n            height={vizHeight}\n            plotRef={(u) => ((this.plotInstance as React.MutableRefObject<uPlot>).current = u)}\n          >\n            {children ? children(config, alignedFrame) : null}\n          </UPlotChart>\n        )}\n      </VizLayout>\n    );\n  }\n}\n","// mutates all nulls -> undefineds in the fieldValues array for value-less refValues ranges below maxThreshold\n// refValues is typically a time array and maxThreshold is the allowable distance between in time\nexport function nullToUndefThreshold(refValues: number[], fieldValues: unknown[], maxThreshold: number) {\n  let prevRef;\n  let nullIdx;\n\n  for (let i = 0; i < fieldValues.length; i++) {\n    let fieldVal = fieldValues[i];\n\n    if (fieldVal == null) {\n      if (nullIdx == null && prevRef != null) {\n        nullIdx = i;\n      }\n    } else {\n      if (nullIdx != null && prevRef != null) {\n        if (refValues[i] - prevRef < maxThreshold) {\n          while (nullIdx < i) {\n            fieldValues[nullIdx++] = undefined;\n          }\n        }\n\n        nullIdx = null;\n      }\n\n      prevRef = refValues[i];\n    }\n  }\n\n  return fieldValues;\n}\n","import { DataFrame, Field, FieldType, outerJoinDataFrames, TimeRange, applyNullInsertThreshold } from '@grafana/data';\nimport { NULL_EXPAND, NULL_REMOVE, NULL_RETAIN, nullToUndefThreshold } from '@grafana/data/internal';\nimport { GraphDrawStyle } from '@grafana/schema';\n\nimport { XYFieldMatchers } from './types';\n\nfunction isVisibleBarField(f: Field) {\n  return (\n    f.type === FieldType.number && f.config.custom?.drawStyle === GraphDrawStyle.Bars && !f.config.custom?.hideFrom?.viz\n  );\n}\n\nexport function getRefField(frame: DataFrame, refFieldName?: string | null) {\n  return frame.fields.find((field) => {\n    // note: getFieldDisplayName() would require full DF[]\n    return refFieldName != null ? field.name === refFieldName : field.type === FieldType.time;\n  });\n}\n\n// will mutate the DataFrame's fields' values\nfunction applySpanNullsThresholds(frame: DataFrame, refFieldName?: string | null) {\n  const refField = getRefField(frame, refFieldName);\n\n  let refValues = refField?.values;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    let field = frame.fields[i];\n\n    if (field === refField || isVisibleBarField(field)) {\n      continue;\n    }\n\n    let spanNulls = field.config.custom?.spanNulls;\n\n    if (typeof spanNulls === 'number') {\n      if (spanNulls !== -1 && refValues) {\n        field.values = nullToUndefThreshold(refValues, field.values, spanNulls);\n      }\n    }\n  }\n\n  return frame;\n}\n\nexport function preparePlotFrame(frames: DataFrame[], dimFields: XYFieldMatchers, timeRange?: TimeRange | null) {\n  let xField: Field;\n  loop: for (let frame of frames) {\n    for (let field of frame.fields) {\n      if (dimFields.x(field, frame, frames)) {\n        xField = field;\n        break loop;\n      }\n    }\n  }\n\n  // apply null insertions at interval\n  frames = frames.map((frame) => {\n    if (!xField?.state?.nullThresholdApplied) {\n      return applyNullInsertThreshold({\n        frame,\n        refFieldName: xField.name,\n        refFieldPseudoMin: timeRange?.from.valueOf(),\n        refFieldPseudoMax: timeRange?.to.valueOf(),\n      });\n    } else {\n      return frame;\n    }\n  });\n\n  let numBarSeries = frames.reduce(\n    (acc, frame) => acc + frame.fields.reduce((acc, field) => acc + (isVisibleBarField(field) ? 1 : 0), 0),\n    0\n  );\n\n  // to make bar widths of all series uniform (equal to narrowest bar series), find smallest distance between x points\n  let minXDelta = Infinity;\n\n  if (numBarSeries > 1) {\n    frames.forEach((frame) => {\n      if (!frame.fields.some(isVisibleBarField)) {\n        return;\n      }\n\n      const xVals = xField.values;\n\n      for (let i = 0; i < xVals.length; i++) {\n        if (i > 0) {\n          minXDelta = Math.min(minXDelta, xVals[i] - xVals[i - 1]);\n        }\n      }\n    });\n  }\n\n  let alignedFrame = outerJoinDataFrames({\n    frames,\n    joinBy: dimFields.x,\n    keep: dimFields.y,\n    keepOriginIndices: true,\n\n    // the join transformer force-deletes our state.displayName cache unless keepDisplayNames: true\n    // https://github.com/grafana/grafana/pull/31121\n    // https://github.com/grafana/grafana/pull/71806\n    keepDisplayNames: true,\n\n    // prevent minesweeper-expansion of nulls (gaps) when joining bars\n    // since bar width is determined from the minimum distance between non-undefined values\n    // (this strategy will still retain any original pre-join nulls, though)\n    nullMode: (field) => {\n      if (isVisibleBarField(field)) {\n        return NULL_RETAIN;\n      }\n\n      let spanNulls = field.config.custom?.spanNulls;\n      return spanNulls === true ? NULL_REMOVE : spanNulls === -1 ? NULL_RETAIN : NULL_EXPAND;\n    },\n  });\n\n  if (alignedFrame) {\n    alignedFrame = applySpanNullsThresholds(alignedFrame, xField!.name);\n\n    // append 2 null vals at minXDelta to bar series\n    if (minXDelta !== Infinity) {\n      alignedFrame.fields.forEach((f, fi) => {\n        let vals = f.values;\n\n        if (fi === 0) {\n          let lastVal = vals[vals.length - 1];\n          vals.push(lastVal + minXDelta, lastVal + 2 * minXDelta);\n        } else if (isVisibleBarField(f)) {\n          vals.push(null, null);\n        } else {\n          vals.push(undefined, undefined);\n        }\n      });\n\n      alignedFrame.length += 2;\n    }\n\n    return alignedFrame;\n  }\n\n  return null;\n}\n","import { isNumber } from 'lodash';\nimport uPlot from 'uplot';\n\nimport {\n  DataFrame,\n  FieldConfig,\n  FieldType,\n  formattedValueToString,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  getFieldDisplayName,\n  getDisplayProcessor,\n  FieldColorModeId,\n  DecimalCount,\n} from '@grafana/data';\n// eslint-disable-next-line import/order\nimport {\n  AxisPlacement,\n  GraphDrawStyle,\n  GraphFieldConfig,\n  GraphThresholdsStyleMode,\n  VisibilityMode,\n  ScaleDirection,\n  ScaleOrientation,\n  StackingMode,\n  GraphTransform,\n  AxisColorMode,\n  GraphGradientMode,\n  VizOrientation,\n} from '@grafana/schema';\n\n// unit lookup needed to determine if we want power-of-2 or power-of-10 axis ticks\n// see categories.ts is @grafana/data\nconst IEC_UNITS = new Set([\n  'bytes',\n  'bits',\n  'kbytes',\n  'mbytes',\n  'gbytes',\n  'tbytes',\n  'pbytes',\n  'binBps',\n  'binbps',\n  'KiBs',\n  'Kibits',\n  'MiBs',\n  'Mibits',\n  'GiBs',\n  'Gibits',\n  'TiBs',\n  'Tibits',\n  'PiBs',\n  'Pibits',\n]);\n\nconst BIN_INCRS = Array(53);\n\nfor (let i = 0; i < BIN_INCRS.length; i++) {\n  BIN_INCRS[i] = 2 ** i;\n}\n\nimport {\n  UPlotConfigBuilder,\n  UPlotConfigPrepFn,\n  getScaleGradientFn,\n  buildScaleKey,\n  getStackingGroups,\n  preparePlotData2,\n} from '@grafana/ui/internal';\n\nconst defaultFormatter = (v: any, decimals: DecimalCount = 1) => (v == null ? '-' : v.toFixed(decimals));\n\nconst defaultConfig: GraphFieldConfig = {\n  drawStyle: GraphDrawStyle.Line,\n  showPoints: VisibilityMode.Auto,\n  axisPlacement: AxisPlacement.Auto,\n};\n\nexport const preparePlotConfigBuilder: UPlotConfigPrepFn = ({\n  frame,\n  theme,\n  timeZones,\n  getTimeRange,\n  allFrames,\n  renderers,\n  tweakScale = (opts) => opts,\n  tweakAxis = (opts) => opts,\n  hoverProximity,\n  orientation = VizOrientation.Horizontal,\n}) => {\n  // we want the Auto and Horizontal orientation to default to Horizontal\n  const isHorizontal = orientation !== VizOrientation.Vertical;\n  const builder = new UPlotConfigBuilder(timeZones[0]);\n\n  let alignedFrame: DataFrame;\n\n  builder.setPrepData((frames) => {\n    // cache alignedFrame\n    alignedFrame = frames[0];\n\n    return preparePlotData2(frames[0], builder.getStackingGroups());\n  });\n\n  // X is the first field in the aligned frame\n  const xField = frame.fields[0];\n  if (!xField) {\n    return builder; // empty frame with no options\n  }\n\n  const xScaleKey = 'x';\n  let yScaleKey = '';\n\n  const xFieldAxisPlacement =\n    xField.config.custom?.axisPlacement === AxisPlacement.Hidden\n      ? AxisPlacement.Hidden\n      : isHorizontal\n        ? AxisPlacement.Bottom\n        : AxisPlacement.Left;\n  const xFieldAxisShow = xField.config.custom?.axisPlacement !== AxisPlacement.Hidden;\n\n  if (xField.type === FieldType.time) {\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: isHorizontal ? ScaleOrientation.Horizontal : ScaleOrientation.Vertical,\n      direction: isHorizontal ? ScaleDirection.Right : ScaleDirection.Up,\n      isTime: true,\n      range: () => {\n        const r = getTimeRange();\n        return [r.from.valueOf(), r.to.valueOf()];\n      },\n    });\n\n    // filters first 2 ticks to make space for timezone labels\n    const filterTicks: uPlot.Axis.Filter | undefined =\n      timeZones.length > 1\n        ? (u, splits) => {\n            if (isHorizontal) {\n              return splits.map((v, i) => (i < 2 ? null : v));\n            }\n            return splits;\n          }\n        : undefined;\n\n    for (let i = 0; i < timeZones.length; i++) {\n      const timeZone = timeZones[i];\n      builder.addAxis({\n        scaleKey: xScaleKey,\n        isTime: true,\n        placement: xFieldAxisPlacement,\n        show: xFieldAxisShow,\n        label: xField.config.custom?.axisLabel,\n        timeZone,\n        theme,\n        grid: { show: i === 0 && xField.config.custom?.axisGridShow },\n        filter: filterTicks,\n      });\n    }\n\n    // render timezone labels\n    if (timeZones.length > 1) {\n      builder.addHook('drawAxes', (u: uPlot) => {\n        u.ctx.save();\n\n        let i = 0;\n        u.axes.forEach((a) => {\n          if (isHorizontal && a.side === 2) {\n            u.ctx.fillStyle = theme.colors.text.primary;\n            u.ctx.textAlign = 'left';\n            u.ctx.textBaseline = 'bottom';\n            //@ts-ignore\n            let cssBaseline: number = a._pos + a._size;\n            u.ctx.fillText(timeZones[i], u.bbox.left, cssBaseline * uPlot.pxRatio);\n            i++;\n          }\n        });\n\n        u.ctx.restore();\n      });\n    }\n  } else {\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: isHorizontal ? ScaleOrientation.Horizontal : ScaleOrientation.Vertical,\n      direction: isHorizontal ? ScaleDirection.Right : ScaleDirection.Up,\n      range: (u, dataMin, dataMax) => [xField.config.min ?? dataMin, xField.config.max ?? dataMax],\n    });\n\n    builder.addAxis({\n      scaleKey: xScaleKey,\n      placement: xFieldAxisPlacement,\n      show: xFieldAxisShow,\n      label: xField.config.custom?.axisLabel,\n      theme,\n      grid: { show: xField.config.custom?.axisGridShow },\n      formatValue: (v, decimals) => formattedValueToString(xField.display!(v, decimals)),\n    });\n  }\n\n  let customRenderedFields =\n    renderers?.flatMap((r) => Object.values(r.fieldMap).filter((name) => r.indicesOnly.indexOf(name) === -1)) ?? [];\n\n  let indexByName: Map<string, number> | undefined;\n\n  for (let i = 1; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    const config: FieldConfig<GraphFieldConfig> = {\n      ...field.config,\n      custom: {\n        ...defaultConfig,\n        ...field.config.custom,\n      },\n    };\n\n    const customConfig: GraphFieldConfig = config.custom!;\n\n    if (field === xField || (field.type !== FieldType.number && field.type !== FieldType.enum)) {\n      continue;\n    }\n\n    let fmt = field.display ?? defaultFormatter;\n    if (field.config.custom?.stacking?.mode === StackingMode.Percent) {\n      fmt = getDisplayProcessor({\n        field: {\n          ...field,\n          config: {\n            ...field.config,\n            unit: 'percentunit',\n          },\n        },\n        theme,\n      });\n    }\n    const scaleKey = buildScaleKey(config, field.type);\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    // The builder will manage unique scaleKeys and combine where appropriate\n    builder.addScale(\n      tweakScale(\n        {\n          scaleKey,\n          orientation: isHorizontal ? ScaleOrientation.Vertical : ScaleOrientation.Horizontal,\n          direction: isHorizontal ? ScaleDirection.Up : ScaleDirection.Right,\n          distribution: customConfig.scaleDistribution?.type,\n          log: customConfig.scaleDistribution?.log,\n          linearThreshold: customConfig.scaleDistribution?.linearThreshold,\n          min: field.config.min,\n          max: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n          centeredZero: customConfig.axisCenteredZero,\n          stackingMode: customConfig.stacking?.mode,\n          range:\n            field.type === FieldType.enum\n              ? (u: uPlot, dataMin: number, dataMax: number) => {\n                  // this is the exhaustive enum (stable)\n                  let len = field.config.type!.enum!.text!.length;\n\n                  return [-1, len];\n\n                  // these are only values that are present\n                  // return [dataMin - 1, dataMax + 1]\n                }\n              : undefined,\n          decimals: field.config.decimals,\n        },\n        field\n      )\n    );\n\n    if (!yScaleKey) {\n      yScaleKey = scaleKey;\n    }\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      let axisColor: uPlot.Axis.Stroke | undefined;\n\n      if (customConfig.axisColorMode === AxisColorMode.Series) {\n        if (\n          colorMode.isByValue &&\n          field.config.custom?.gradientMode === GraphGradientMode.Scheme &&\n          colorMode.id === FieldColorModeId.Thresholds\n        ) {\n          axisColor = getScaleGradientFn(1, theme, colorMode, field.config.thresholds);\n        } else {\n          axisColor = seriesColor;\n        }\n      }\n\n      const axisDisplayOptions = {\n        border: {\n          show: customConfig.axisBorderShow || false,\n          width: 1 / devicePixelRatio,\n          stroke: axisColor || theme.colors.text.primary,\n        },\n        ticks: {\n          show: customConfig.axisBorderShow || false,\n          stroke: axisColor || theme.colors.text.primary,\n        },\n        color: axisColor || theme.colors.text.primary,\n      };\n\n      let incrs: uPlot.Axis.Incrs | undefined;\n\n      // TODO: these will be dynamic with frame updates, so need to accept getYTickLabels()\n      let values: uPlot.Axis.Values | undefined;\n      let splits: uPlot.Axis.Splits | undefined;\n\n      if (IEC_UNITS.has(config.unit!)) {\n        incrs = BIN_INCRS;\n      } else if (field.type === FieldType.enum) {\n        let text = field.config.type!.enum!.text!;\n        splits = text.map((v: string, i: number) => i);\n        values = text;\n      }\n\n      builder.addAxis(\n        tweakAxis(\n          {\n            scaleKey,\n            label: customConfig.axisLabel,\n            size: customConfig.axisWidth,\n            placement: isHorizontal ? (customConfig.axisPlacement ?? AxisPlacement.Auto) : AxisPlacement.Bottom,\n            formatValue: (v, decimals) => formattedValueToString(fmt(v, decimals)),\n            theme,\n            grid: { show: customConfig.axisGridShow },\n            decimals: field.config.decimals,\n            distr: customConfig.scaleDistribution?.type,\n            splits,\n            values,\n            incrs,\n            ...axisDisplayOptions,\n          },\n          field\n        )\n      );\n    }\n\n    const showPoints =\n      customConfig.drawStyle === GraphDrawStyle.Points ? VisibilityMode.Always : customConfig.showPoints;\n\n    let pointsFilter: uPlot.Series.Points.Filter = () => null;\n\n    if (customConfig.spanNulls !== true) {\n      pointsFilter = (u, seriesIdx, show, gaps) => {\n        let filtered = [];\n\n        let series = u.series[seriesIdx];\n\n        if (!show && gaps && gaps.length) {\n          const [firstIdx, lastIdx] = series.idxs!;\n          const xData = u.data[0];\n          const yData = u.data[seriesIdx];\n          const firstPos = Math.round(u.valToPos(xData[firstIdx], 'x', true));\n          const lastPos = Math.round(u.valToPos(xData[lastIdx], 'x', true));\n\n          if (gaps[0][0] === firstPos) {\n            filtered.push(firstIdx);\n          }\n\n          // show single points between consecutive gaps that share end/start\n          for (let i = 0; i < gaps.length; i++) {\n            let thisGap = gaps[i];\n            let nextGap = gaps[i + 1];\n\n            if (nextGap && thisGap[1] === nextGap[0]) {\n              // approx when data density is > 1pt/px, since gap start/end pixels are rounded\n              let approxIdx = u.posToIdx(thisGap[1], true);\n\n              if (yData[approxIdx] == null) {\n                // scan left/right alternating to find closest index with non-null value\n                for (let j = 1; j < 100; j++) {\n                  if (yData[approxIdx + j] != null) {\n                    approxIdx += j;\n                    break;\n                  }\n                  if (yData[approxIdx - j] != null) {\n                    approxIdx -= j;\n                    break;\n                  }\n                }\n              }\n\n              filtered.push(approxIdx);\n            }\n          }\n\n          if (gaps[gaps.length - 1][1] === lastPos) {\n            filtered.push(lastIdx);\n          }\n        }\n\n        return filtered.length ? filtered : null;\n      };\n    }\n\n    let { fillOpacity } = customConfig;\n\n    let pathBuilder: uPlot.Series.PathBuilder | null = null;\n    let pointsBuilder: uPlot.Series.Points.Show | null = null;\n\n    if (field.state?.origin) {\n      if (!indexByName) {\n        indexByName = getNamesToFieldIndex(frame, allFrames);\n      }\n\n      const originFrame = allFrames[field.state.origin.frameIndex];\n      const originField = originFrame?.fields[field.state.origin.fieldIndex];\n\n      const dispName = getFieldDisplayName(originField ?? field, originFrame, allFrames);\n\n      // disable default renderers\n      if (customRenderedFields.indexOf(dispName) >= 0) {\n        pathBuilder = () => null;\n        pointsBuilder = () => undefined;\n      } else if (customConfig.transform === GraphTransform.Constant) {\n        // patch some monkeys!\n        const defaultBuilder = uPlot.paths!.linear!();\n\n        pathBuilder = (u, seriesIdx) => {\n          //eslint-disable-next-line\n          const _data: any[] = (u as any)._data; // uplot.AlignedData not exposed in types\n\n          // the data we want the line renderer to pull is x at each plot edge with paired flat y values\n\n          const r = getTimeRange();\n          let xData = [r.from.valueOf(), r.to.valueOf()];\n          let firstY = _data[seriesIdx].find((v: number | null | undefined) => v != null);\n          let yData = [firstY, firstY];\n          let fauxData = _data.slice();\n          fauxData[0] = xData;\n          fauxData[seriesIdx] = yData;\n\n          //eslint-disable-next-line\n          return defaultBuilder(\n            {\n              ...u,\n              _data: fauxData,\n            } as any,\n            seriesIdx,\n            0,\n            1\n          );\n        };\n      }\n\n      if (customConfig.fillBelowTo) {\n        const fillBelowToField = frame.fields.find(\n          (f) =>\n            customConfig.fillBelowTo === f.name ||\n            customConfig.fillBelowTo === f.config?.displayNameFromDS ||\n            customConfig.fillBelowTo === getFieldDisplayName(f, frame, allFrames)\n        );\n\n        const fillBelowDispName = fillBelowToField\n          ? getFieldDisplayName(fillBelowToField, frame, allFrames)\n          : customConfig.fillBelowTo;\n\n        const t = indexByName.get(dispName);\n        const b = indexByName.get(fillBelowDispName);\n        if (isNumber(b) && isNumber(t)) {\n          builder.addBand({\n            series: [t, b],\n            fill: undefined, // using null will have the band use fill options from `t`\n          });\n\n          if (!fillOpacity) {\n            fillOpacity = 35; // default from flot\n          }\n        } else {\n          fillOpacity = 0;\n        }\n      }\n    }\n\n    let dynamicSeriesColor: ((seriesIdx: number) => string | undefined) | undefined = undefined;\n\n    if (colorMode.id === FieldColorModeId.Thresholds) {\n      dynamicSeriesColor = (seriesIdx) => getFieldSeriesColor(alignedFrame.fields[seriesIdx], theme).color;\n    }\n\n    builder.addSeries({\n      pathBuilder,\n      pointsBuilder,\n      scaleKey,\n      showPoints,\n      pointsFilter,\n      colorMode,\n      fillOpacity,\n      theme,\n      dynamicSeriesColor,\n      drawStyle: customConfig.drawStyle!,\n      lineColor: customConfig.lineColor ?? seriesColor,\n      lineWidth: customConfig.lineWidth,\n      lineInterpolation: customConfig.lineInterpolation,\n      lineStyle: customConfig.lineStyle,\n      barAlignment: customConfig.barAlignment,\n      barWidthFactor: customConfig.barWidthFactor,\n      barMaxWidth: customConfig.barMaxWidth,\n      pointSize: customConfig.pointSize,\n      spanNulls: customConfig.spanNulls || false,\n      show: !customConfig.hideFrom?.viz,\n      gradientMode: customConfig.gradientMode,\n      thresholds: config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: field.state?.origin,\n    });\n\n    // Render thresholds in graph\n    if (customConfig.thresholdsStyle && config.thresholds) {\n      const thresholdDisplay = customConfig.thresholdsStyle.mode ?? GraphThresholdsStyleMode.Off;\n      if (thresholdDisplay !== GraphThresholdsStyleMode.Off) {\n        builder.addThresholds({\n          config: customConfig.thresholdsStyle,\n          thresholds: config.thresholds,\n          scaleKey,\n          theme,\n          hardMin: field.config.min,\n          hardMax: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n        });\n      }\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n\n  builder.setStackingGroups(stackingGroups);\n\n  // hook up custom/composite renderers\n  renderers?.forEach((r) => {\n    if (!indexByName) {\n      indexByName = getNamesToFieldIndex(frame, allFrames);\n    }\n    let fieldIndices: Record<string, number> = {};\n\n    for (let key in r.fieldMap) {\n      let dispName = r.fieldMap[key];\n      fieldIndices[key] = indexByName.get(dispName)!;\n    }\n\n    r.init(builder, fieldIndices);\n  });\n\n  // if hovered value is null, how far we may scan left/right to hover nearest non-null\n  const DEFAULT_HOVER_NULL_PROXIMITY = 15;\n  const DEFAULT_FOCUS_PROXIMITY = 30;\n\n  let cursor: Partial<uPlot.Cursor> = {\n    // horizontal proximity / point hover behavior\n    hover: {\n      prox: (self, seriesIdx, hoveredIdx) => {\n        if (hoverProximity != null) {\n          return hoverProximity;\n        }\n\n        // when hovering null values, scan data left/right up to 15px\n        const yVal = self.data[seriesIdx][hoveredIdx];\n        if (yVal === null) {\n          return DEFAULT_HOVER_NULL_PROXIMITY;\n        }\n\n        // no proximity limit\n        return null;\n      },\n      skip: [null],\n    },\n    // vertical proximity / series focus behavior\n    focus: {\n      prox: hoverProximity ?? DEFAULT_FOCUS_PROXIMITY,\n    },\n    points: { one: true },\n  };\n\n  builder.setCursor(cursor);\n\n  return builder;\n};\n\nfunction getNamesToFieldIndex(frame: DataFrame, allFrames: DataFrame[]): Map<string, number> {\n  const originNames = new Map<string, number>();\n  frame.fields.forEach((field, i) => {\n    const origin = field.state?.origin;\n    if (origin) {\n      const origField = allFrames[origin.frameIndex]?.fields[origin.fieldIndex];\n      if (origField) {\n        originNames.set(getFieldDisplayName(origField, allFrames[origin.frameIndex], allFrames), i);\n      }\n    }\n  });\n  return originNames;\n}\n","import { Component } from 'react';\n\nimport { DataFrame, TimeRange } from '@grafana/data';\nimport { withTheme2 } from '@grafana/ui';\nimport { hasVisibleLegendSeries, PlotLegend, UPlotConfigBuilder } from '@grafana/ui/internal';\n\nimport { GraphNG, GraphNGProps, PropDiffFn } from '../GraphNG/GraphNG';\n\nimport { preparePlotConfigBuilder } from './utils';\n\nconst propsToDiff: Array<string | PropDiffFn> = ['legend', 'options', 'theme'];\n\ntype TimeSeriesProps = Omit<GraphNGProps, 'prepConfig' | 'propsToDiff' | 'renderLegend'>;\n\nexport class UnthemedTimeSeries extends Component<TimeSeriesProps> {\n  prepConfig = (alignedFrame: DataFrame, allFrames: DataFrame[], getTimeRange: () => TimeRange) => {\n    const { theme, timeZone, options, renderers, tweakAxis, tweakScale } = this.props;\n\n    return preparePlotConfigBuilder({\n      frame: alignedFrame,\n      theme,\n      timeZones: Array.isArray(timeZone) ? timeZone : [timeZone],\n      getTimeRange,\n      allFrames,\n      renderers,\n      tweakScale,\n      tweakAxis,\n      hoverProximity: options?.tooltip?.hoverProximity,\n      orientation: options?.orientation,\n    });\n  };\n\n  renderLegend = (config: UPlotConfigBuilder) => {\n    const { legend, frames } = this.props;\n\n    if (!config || (legend && !legend.showLegend) || !hasVisibleLegendSeries(config, frames)) {\n      return null;\n    }\n\n    return <PlotLegend data={frames} config={config} {...legend} />;\n  };\n\n  render() {\n    return (\n      <GraphNG\n        {...this.props}\n        prepConfig={this.prepConfig}\n        propsToDiff={propsToDiff}\n        renderLegend={this.renderLegend}\n      />\n    );\n  }\n}\n\nexport const TimeSeries = withTheme2(UnthemedTimeSeries);\nTimeSeries.displayName = 'TimeSeries';\n","import { ReactNode } from 'react';\n\nimport { DataFrame, Field, FieldType, formattedValueToString, InterpolateFunction, LinkModel } from '@grafana/data';\nimport { SortOrder, TooltipDisplayMode } from '@grafana/schema/dist/esm/common/common.gen';\nimport {\n  VizTooltipContent,\n  VizTooltipFooter,\n  VizTooltipHeader,\n  VizTooltipWrapper,\n  getContentItems,\n  VizTooltipItem,\n} from '@grafana/ui/internal';\n\nimport { getFieldActions } from '../status-history/utils';\nimport { fmt } from '../xychart/utils';\n\nimport { isTooltipScrollable } from './utils';\n\n// exemplar / annotation / time region hovering?\n// add annotation UI / alert dismiss UI?\n\nexport interface TimeSeriesTooltipProps {\n  // aligned series frame\n  series: DataFrame;\n\n  // aligned fields that are not series\n  _rest?: Field[];\n\n  // hovered points\n  dataIdxs: Array<number | null>;\n  // closest/hovered series\n  seriesIdx?: number | null;\n  mode?: TooltipDisplayMode;\n  sortOrder?: SortOrder;\n\n  isPinned: boolean;\n\n  annotate?: () => void;\n  maxHeight?: number;\n\n  replaceVariables?: InterpolateFunction;\n  dataLinks: LinkModel[];\n  hideZeros?: boolean;\n}\n\nexport const TimeSeriesTooltip = ({\n  series,\n  _rest,\n  dataIdxs,\n  seriesIdx,\n  mode = TooltipDisplayMode.Single,\n  sortOrder = SortOrder.None,\n  isPinned,\n  annotate,\n  maxHeight,\n  replaceVariables = (str) => str,\n  dataLinks,\n  hideZeros,\n}: TimeSeriesTooltipProps) => {\n  const xField = series.fields[0];\n  const xVal = formattedValueToString(xField.display!(xField.values[dataIdxs[0]!]));\n\n  const contentItems = getContentItems(\n    series.fields,\n    xField,\n    dataIdxs,\n    seriesIdx,\n    mode,\n    sortOrder,\n    (field) => field.type === FieldType.number || field.type === FieldType.enum,\n    hideZeros\n  );\n\n  _rest?.forEach((field) => {\n    if (!field.config.custom?.hideFrom?.tooltip) {\n      contentItems.push({\n        label: field.state?.displayName ?? field.name,\n        value: fmt(field, field.values[dataIdxs[0]!]),\n      });\n    }\n  });\n\n  let footer: ReactNode;\n\n  if (seriesIdx != null) {\n    const field = series.fields[seriesIdx];\n    const hasOneClickLink = dataLinks.some((dataLink) => dataLink.oneClick === true);\n\n    if (isPinned || hasOneClickLink) {\n      const dataIdx = dataIdxs[seriesIdx]!;\n      const actions = getFieldActions(series, field, replaceVariables, dataIdx);\n\n      footer = <VizTooltipFooter dataLinks={dataLinks} actions={actions} annotate={annotate} />;\n    }\n  }\n\n  const headerItem: VizTooltipItem | null = xField.config.custom?.hideFrom?.tooltip\n    ? null\n    : {\n        label: xField.type === FieldType.time ? '' : (xField.state?.displayName ?? xField.name),\n        value: xVal,\n      };\n\n  return (\n    <VizTooltipWrapper>\n      {headerItem != null && <VizTooltipHeader item={headerItem} isPinned={isPinned} />}\n      <VizTooltipContent\n        items={contentItems}\n        isPinned={isPinned}\n        scrollable={isTooltipScrollable({ mode, maxHeight })}\n        maxHeight={maxHeight}\n      />\n      {footer}\n    </VizTooltipWrapper>\n  );\n};\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as common from '@grafana/schema';\n\nexport enum PointShape {\n  Circle = 'circle',\n  Square = 'square',\n}\n\nexport enum SeriesMapping {\n  Auto = 'auto',\n  Manual = 'manual',\n}\n\nexport enum XYShowMode {\n  Lines = 'lines',\n  Points = 'points',\n  PointsAndLines = 'points+lines',\n}\n\n/**\n * NOTE: (copied from dashboard_kind.cue, since not exported)\n * Matcher is a predicate configuration. Based on the config a set of field(s) or values is filtered in order to apply override / transformation.\n * It comes with in id ( to resolve implementation from registry) and a configuration that’s specific to a particular matcher type.\n */\nexport interface MatcherConfig {\n  /**\n   * The matcher id. This is used to find the matcher implementation from registry.\n   */\n  id: string;\n  /**\n   * The matcher options. This is specific to the matcher implementation.\n   */\n  options?: unknown;\n}\n\nexport const defaultMatcherConfig: Partial<MatcherConfig> = {\n  id: '',\n};\n\nexport interface FieldConfig extends common.HideableFieldConfig, common.AxisConfig {\n  fillOpacity?: number;\n  lineStyle?: common.LineStyle;\n  lineWidth?: number;\n  pointShape?: PointShape;\n  pointSize?: {\n    fixed?: number;\n    min?: number;\n    max?: number;\n  };\n  pointStrokeWidth?: number;\n  show?: XYShowMode;\n}\n\nexport const defaultFieldConfig: Partial<FieldConfig> = {\n  fillOpacity: 50,\n  show: XYShowMode.Points,\n};\n\nexport interface XYSeriesConfig {\n  color?: {\n    matcher: MatcherConfig;\n  };\n  frame?: {\n    matcher: MatcherConfig;\n  };\n  name?: {\n    fixed?: string;\n  };\n  size?: {\n    matcher: MatcherConfig;\n  };\n  x?: {\n    matcher: MatcherConfig;\n  };\n  y?: {\n    matcher: MatcherConfig;\n  };\n}\n\nexport interface Options extends common.OptionsWithLegend, common.OptionsWithTooltip {\n  mapping: SeriesMapping;\n  series: Array<XYSeriesConfig>;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  series: [],\n};\n","import {\n  Field,\n  formattedValueToString,\n  getFieldMatcher,\n  FieldType,\n  getFieldDisplayName,\n  DataFrame,\n  FrameMatcherID,\n  MatcherConfig,\n  FieldColorModeId,\n  cacheFieldDisplayNames,\n  FieldMatcherID,\n  FieldConfigSource,\n} from '@grafana/data';\nimport { decoupleHideFromState } from '@grafana/data/internal';\nimport { config } from '@grafana/runtime';\nimport { VisibilityMode } from '@grafana/schema';\n\nimport { XYShowMode, SeriesMapping, XYSeriesConfig } from './panelcfg.gen';\nimport { XYSeries } from './types2';\n\nexport function fmt(field: Field, val: number): string {\n  if (field.display) {\n    return formattedValueToString(field.display(val));\n  }\n\n  return `${val}`;\n}\n\n// cause we dont have a proper matcher for this currently\nfunction getFrameMatcher2(config: MatcherConfig) {\n  if (config.id === FrameMatcherID.byIndex) {\n    return (frame: DataFrame, index: number) => index === config.options;\n  }\n\n  return () => false;\n}\n\nexport function prepSeries(\n  mapping: SeriesMapping,\n  mappedSeries: XYSeriesConfig[],\n  frames: DataFrame[],\n  fieldConfig: FieldConfigSource\n) {\n  cacheFieldDisplayNames(frames);\n  decoupleHideFromState(frames, fieldConfig);\n\n  let series: XYSeries[] = [];\n\n  if (mappedSeries.length === 0) {\n    mappedSeries = [{}];\n  }\n\n  const { palette, getColorByName } = config.theme2.visualization;\n\n  mappedSeries.forEach((seriesCfg, seriesIdx) => {\n    if (mapping === SeriesMapping.Manual) {\n      if (seriesCfg.frame?.matcher == null || seriesCfg.x?.matcher == null || seriesCfg.y?.matcher == null) {\n        return;\n      }\n    }\n\n    let xMatcher = getFieldMatcher(\n      seriesCfg.x?.matcher ?? {\n        id: FieldMatcherID.byType,\n        options: 'number',\n      }\n    );\n    let yMatcher = getFieldMatcher(\n      seriesCfg.y?.matcher ?? {\n        id: FieldMatcherID.byType,\n        options: 'number',\n      }\n    );\n    let colorMatcher = seriesCfg.color ? getFieldMatcher(seriesCfg.color.matcher) : null;\n    let sizeMatcher = seriesCfg.size ? getFieldMatcher(seriesCfg.size.matcher) : null;\n    // let frameMatcher = seriesCfg.frame ? getFrameMatchers(seriesCfg.frame) : null;\n    let frameMatcher = seriesCfg.frame ? getFrameMatcher2(seriesCfg.frame.matcher) : null;\n\n    // loop over all frames and fields, adding a new series for each y dim\n    frames.forEach((frame, frameIdx) => {\n      // must match frame in manual mode\n      if (frameMatcher != null && !frameMatcher(frame, frameIdx)) {\n        return;\n      }\n\n      // shared across each series in this frame\n      let restFields: Field[] = [];\n\n      let frameSeries: XYSeries[] = [];\n\n      // only grabbing number fields (exclude time, string, enum, other)\n      let onlyNumFields = frame.fields.filter((field) => field.type === FieldType.number);\n\n      // only one of these per frame\n      let x = onlyNumFields.find((field) => xMatcher(field, frame, frames));\n      let color =\n        colorMatcher != null\n          ? onlyNumFields.find((field) => field !== x && colorMatcher!(field, frame, frames))\n          : undefined;\n      let size =\n        sizeMatcher != null\n          ? onlyNumFields.find((field) => field !== x && field !== color && sizeMatcher!(field, frame, frames))\n          : undefined;\n\n      // x field is required\n      if (x != null) {\n        // match y fields and create series\n        onlyNumFields.forEach((field) => {\n          if (field === x) {\n            return;\n          }\n\n          // in auto mode don't reuse already-mapped fields\n          if (mapping === SeriesMapping.Auto && (field === color || field === size)) {\n            return;\n          }\n\n          // in manual mode only add single series for this config\n          if (mapping === SeriesMapping.Manual && frameSeries.length > 0) {\n            return;\n          }\n\n          // if we match non-excluded y, create series\n          if (yMatcher(field, frame, frames) && !field.config.custom?.hideFrom?.viz) {\n            let y = field;\n\n            let name = seriesCfg.name?.fixed;\n\n            if (name == null) {\n              // if the displayed field name is likely to have a common prefix or suffix\n              // (such as those from Partition by values transformation)\n              const likelyHasCommonParts =\n                frames.length > 1 && (frame.name != null || Object.keys(y.labels ?? {}).length > 0);\n\n              // if the field was explictly (re)named using config.displayName or config.displayNameFromDS\n              // we still want to retain any frame name prefix or suffix so that autoNameSeries() can\n              // properly detect + strip common parts across all series...\n              const { displayName, displayNameFromDS } = y.config;\n              const hasExplicitName = displayName != null || displayNameFromDS != null;\n\n              if (likelyHasCommonParts && hasExplicitName) {\n                // ...and a hacky way to do this is to temp remove the explicit name, get the auto name, then revert\n                const stateDisplayName = y.state!.displayName;\n\n                // clear config and cache\n                y.config.displayName = y.config.displayNameFromDS = y.state!.displayName = undefined;\n                // get default/calculated display name (maybe use calculateFieldDisplayName() here instead?)\n                name = getFieldDisplayName(y, frame, frames);\n                // replace original field name with explicit one\n                name = name.replace(y.name, (displayNameFromDS ?? displayName)!);\n\n                // revert\n                y.config.displayName = displayName;\n                y.config.displayNameFromDS = displayNameFromDS;\n                y.state!.displayName = stateDisplayName;\n              } else {\n                name = getFieldDisplayName(y, frame, frames);\n              }\n            }\n\n            let ser: XYSeries = {\n              // these typically come from y field\n              name: {\n                value: name,\n              },\n\n              showPoints: y.config.custom.show === XYShowMode.Lines ? VisibilityMode.Never : VisibilityMode.Always,\n              pointShape: y.config.custom.pointShape,\n              pointStrokeWidth: y.config.custom.pointStrokeWidth,\n              fillOpacity: y.config.custom.fillOpacity,\n\n              showLine: y.config.custom.show !== XYShowMode.Points,\n              lineWidth: y.config.custom.lineWidth ?? 2,\n              lineStyle: y.config.custom.lineStyle,\n\n              x: {\n                field: x!,\n              },\n              y: {\n                field: y,\n              },\n              color: {},\n              size: {},\n              _rest: restFields,\n            };\n\n            if (color != null) {\n              ser.color.field = color;\n            }\n\n            if (size != null) {\n              ser.size.field = size;\n              ser.size.min = size.config.custom.pointSize?.min ?? 5;\n              ser.size.max = size.config.custom.pointSize?.max ?? 100;\n              // ser.size.mode =\n            }\n\n            frameSeries.push(ser);\n          }\n        });\n\n        if (frameSeries.length === 0) {\n          // TODO: could not create series, skip & show error?\n        }\n\n        // populate rest fields\n        frame.fields.forEach((field) => {\n          let isUsedField = frameSeries.some(\n            ({ x, y, color, size }) =>\n              x.field === field || y.field === field || color.field === field || size.field === field\n          );\n\n          if (!isUsedField) {\n            restFields.push(field);\n          }\n        });\n\n        series.push(...frameSeries);\n      } else {\n        // x is missing in this frame!\n      }\n    });\n  });\n\n  if (series.length === 0) {\n    // TODO: could not create series, skip & show error?\n  } else {\n    // assign classic palette colors by index, as fallbacks for all series\n\n    let paletteIdx = 0;\n\n    // todo: populate min, max, mode from field + hints\n    series.forEach((s, i) => {\n      if (s.color.field == null) {\n        // derive fixed color from y field config\n        let colorCfg = s.y.field.config.color ?? { mode: FieldColorModeId.PaletteClassic };\n\n        let value = '';\n\n        if (colorCfg.mode === FieldColorModeId.PaletteClassic) {\n          value = getColorByName(palette[paletteIdx++ % palette.length]); // todo: do this via state.seriesIdx and re-init displayProcessor\n        } else if (colorCfg.mode === FieldColorModeId.Fixed) {\n          value = getColorByName(colorCfg.fixedColor!);\n        }\n\n        s.color.fixed = value;\n      }\n\n      if (s.size.field == null) {\n        // derive fixed size from y field config\n        s.size.fixed = s.y.field.config.custom.pointSize?.fixed ?? 5;\n        // ser.size.mode =\n      }\n    });\n\n    autoNameSeries(series);\n\n    // TODO: re-assign y display names?\n    // y.state = {\n    //   ...y.state,\n    //   seriesIndex: series.length + ,\n    // };\n    // y.display = getDisplayProcessor({ field, theme });\n  }\n\n  return series;\n}\n\n// strip common prefixes and suffixes from y field names\nfunction autoNameSeries(series: XYSeries[]) {\n  let names = series.map((s) => s.name.value.split(/\\s+/g));\n\n  const { prefix, suffix } = findCommonPrefixSuffixLengths(names);\n\n  if (prefix < Infinity || suffix < Infinity) {\n    series.forEach((s, i) => {\n      s.name.value = names[i].slice(prefix, names[i].length - suffix).join(' ');\n    });\n  }\n}\n\nexport function getCommonPrefixSuffix(strs: string[]) {\n  let names = strs.map((s) => s.split(/\\s+/g));\n\n  let { prefix, suffix } = findCommonPrefixSuffixLengths(names);\n\n  let n = names[0];\n\n  if (n.length === 1 && prefix === 1 && suffix === 1) {\n    return '';\n  }\n\n  let parts = [];\n\n  if (prefix > 0) {\n    parts.push(...n.slice(0, prefix));\n  }\n\n  if (suffix > 0) {\n    parts.push(...n.slice(-suffix));\n  }\n\n  return parts.join(' ');\n}\n\n// lengths are in number of tokens (segments) in a phrase\nfunction findCommonPrefixSuffixLengths(names: string[][]) {\n  let commonPrefixLen = Infinity;\n  let commonSuffixLen = Infinity;\n\n  // if auto naming strategy, rename fields by stripping common prefixes and suffixes\n  let segs0: string[] = names[0];\n\n  for (let i = 1; i < names.length; i++) {\n    if (names[i].length < segs0.length) {\n      segs0 = names[i];\n    }\n  }\n\n  for (let i = 1; i < names.length; i++) {\n    let segs = names[i];\n\n    if (segs !== segs0) {\n      // prefixes\n      let preLen = 0;\n      for (let j = 0; j < segs0.length; j++) {\n        if (segs[j] === segs0[j]) {\n          preLen++;\n        } else {\n          break;\n        }\n      }\n\n      if (preLen < commonPrefixLen) {\n        commonPrefixLen = preLen;\n      }\n\n      // suffixes\n      let sufLen = 0;\n      for (let j = segs0.length - 1; j >= 0; j--) {\n        if (segs[j] === segs0[j]) {\n          sufLen++;\n        } else {\n          break;\n        }\n      }\n\n      if (sufLen < commonSuffixLen) {\n        commonSuffixLen = sufLen;\n      }\n    }\n  }\n\n  return {\n    prefix: commonPrefixLen,\n    suffix: commonSuffixLen,\n  };\n}\n"],"names":["sameProps","prevProps","nextProps","propsToDiff","propName","defaultMatchers","GraphNG","props","state","withConfig","frames","fields","preparePlotFrame","replaceVariables","dataLinkPostProcessor","preparePlotFrameFn","withLinks","frame","field","alignedFrame","alignedFrameFinal","timeZone","linkFrames","frameIdx","fieldIdx","linkFrame","frameIndex","i","nonHiddenFields","config","structureRev","cursorSync","propsChanged","newState","width","height","children","renderLegend","alignedData","vizWidth","vizHeight","u","nullToUndefThreshold","refValues","fieldValues","maxThreshold","prevRef","nullIdx","isVisibleBarField","f","getRefField","refFieldName","applySpanNullsThresholds","refField","spanNulls","dimFields","timeRange","xField","loop","numBarSeries","acc","minXDelta","xVals","fi","vals","lastVal","IEC_UNITS","BIN_INCRS","defaultFormatter","v","decimals","defaultConfig","preparePlotConfigBuilder","theme","timeZones","getTimeRange","allFrames","renderers","tweakScale","opts","tweakAxis","hoverProximity","orientation","isHorizontal","builder","UPlotConfigBuilder","xScaleKey","yScaleKey","xFieldAxisPlacement","xFieldAxisShow","r","filterTicks","splits","a","cssBaseline","dataMin","dataMax","customRenderedFields","name","indexByName","customConfig","fmt","scaleKey","colorMode","seriesColor","axisColor","axisDisplayOptions","incrs","values","text","showPoints","pointsFilter","seriesIdx","show","gaps","filtered","series","firstIdx","lastIdx","xData","yData","firstPos","lastPos","thisGap","nextGap","approxIdx","j","fillOpacity","pathBuilder","pointsBuilder","getNamesToFieldIndex","originFrame","originField","dispName","defaultBuilder","_data","firstY","fauxData","fillBelowToField","fillBelowDispName","t","b","dynamicSeriesColor","stackingGroups","fieldIndices","key","DEFAULT_HOVER_NULL_PROXIMITY","cursor","self","hoveredIdx","originNames","origin","origField","UnthemedTimeSeries","options","legend","PlotLegend","TimeSeries","TimeSeriesTooltip","_rest","dataIdxs","mode","sortOrder","isPinned","annotate","maxHeight","str","dataLinks","hideZeros","xVal","contentItems","footer","hasOneClickLink","dataLink","dataIdx","actions","headerItem","PointShape","SeriesMapping","XYShowMode","defaultMatcherConfig","defaultFieldConfig","defaultOptions","val","getFrameMatcher2","index","prepSeries","mapping","mappedSeries","fieldConfig","palette","getColorByName","seriesCfg","xMatcher","yMatcher","colorMatcher","sizeMatcher","frameMatcher","restFields","frameSeries","onlyNumFields","x","color","size","y","likelyHasCommonParts","displayName","displayNameFromDS","hasExplicitName","stateDisplayName","ser","paletteIdx","s","colorCfg","value","autoNameSeries","names","prefix","suffix","findCommonPrefixSuffixLengths","getCommonPrefixSuffix","strs","n","parts","commonPrefixLen","commonSuffixLen","segs0","segs","preLen","sufLen"],"sourceRoot":""}