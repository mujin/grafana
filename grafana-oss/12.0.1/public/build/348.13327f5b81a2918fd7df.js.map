{"version":3,"file":"348.13327f5b81a2918fd7df.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/barchart/quadtree.ts","webpack://grafana/./public/app/plugins/panel/heatmap/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/heatmap/types.ts","webpack://grafana/./public/app/plugins/panel/heatmap/utils.ts"],"sourcesContent":["const MAX_OBJECTS = 10;\nconst MAX_LEVELS = 4;\n\nexport type Quads = [Quadtree, Quadtree, Quadtree, Quadtree];\nexport type Rect = { x: number; y: number; w: number; h: number; [_: string]: any };\n\n/**\n * @internal\n */\nexport function pointWithin(px: number, py: number, rlft: number, rtop: number, rrgt: number, rbtm: number) {\n  return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;\n}\n\n/**\n * @internal\n */\nexport function findRects(qt: Quadtree, sidx?: number, didx?: number) {\n  let rects: Rect[] = [];\n\n  if (qt.o.length) {\n    rects.push(...qt.o.filter((rect) => (sidx == null || rect.sidx === sidx) && (didx == null || rect.didx === didx)));\n  }\n\n  if (qt.q) {\n    for (let i = 0; i < qt.q.length; i++) {\n      rects.push(...findRects(qt.q[i], sidx, didx));\n    }\n  }\n\n  return rects;\n}\n\n/**\n * @internal\n *\n * Determines if r2 is intersected by r1.\n */\nexport function intersects(r1: Rect, r2: Rect) {\n  return r1.x <= r2.x + r2.w && r1.x + r1.w >= r2.x && r1.y + r1.h >= r2.y && r1.y <= r2.y + r2.h;\n}\n\n/**\n * @internal\n */\nexport class Quadtree {\n  o: Rect[];\n  q: Quads | null;\n\n  constructor(\n    public x: number,\n    public y: number,\n    public w: number,\n    public h: number,\n    public l = 0\n  ) {\n    this.o = [];\n    this.q = null;\n  }\n\n  split() {\n    let t = this,\n      x = t.x,\n      y = t.y,\n      w = t.w / 2,\n      h = t.h / 2,\n      l = t.l + 1;\n\n    t.q = [\n      // top right\n      new Quadtree(x + w, y, w, h, l),\n      // top left\n      new Quadtree(x, y, w, h, l),\n      // bottom left\n      new Quadtree(x, y + h, w, h, l),\n      // bottom right\n      new Quadtree(x + w, y + h, w, h, l),\n    ];\n  }\n\n  // invokes callback with index of each overlapping quad\n  quads(x: number, y: number, w: number, h: number, cb: (q: Quadtree) => void) {\n    let t = this,\n      q = t.q!,\n      hzMid = t.x + t.w / 2,\n      vtMid = t.y + t.h / 2,\n      startIsNorth = y < vtMid,\n      startIsWest = x < hzMid,\n      endIsEast = x + w > hzMid,\n      endIsSouth = y + h > vtMid;\n\n    // top-right quad\n    startIsNorth && endIsEast && cb(q[0]);\n    // top-left quad\n    startIsWest && startIsNorth && cb(q[1]);\n    // bottom-left quad\n    startIsWest && endIsSouth && cb(q[2]);\n    // bottom-right quad\n    endIsEast && endIsSouth && cb(q[3]);\n  }\n\n  add(o: Rect) {\n    let t = this;\n\n    if (t.q != null) {\n      t.quads(o.x, o.y, o.w, o.h, (q) => {\n        q.add(o);\n      });\n    } else {\n      let os = t.o;\n\n      os.push(o);\n\n      if (os.length > MAX_OBJECTS && t.l < MAX_LEVELS) {\n        t.split();\n\n        for (let i = 0; i < os.length; i++) {\n          let oi = os[i];\n\n          t.quads(oi.x, oi.y, oi.w, oi.h, (q) => {\n            q.add(oi);\n          });\n        }\n\n        t.o.length = 0;\n      }\n    }\n  }\n\n  get(x: number, y: number, w: number, h: number, cb: (o: Rect) => void) {\n    let t = this;\n    let os = t.o;\n\n    for (let i = 0; i < os.length; i++) {\n      cb(os[i]);\n    }\n\n    if (t.q != null) {\n      t.quads(x, y, w, h, (q) => {\n        q.get(x, y, w, h, cb);\n      });\n    }\n  }\n\n  clear() {\n    this.o.length = 0;\n    this.q = null;\n  }\n}\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as ui from '@grafana/schema';\n\n/**\n * Controls the color mode of the heatmap\n */\nexport enum HeatmapColorMode {\n  Opacity = 'opacity',\n  Scheme = 'scheme',\n}\n\n/**\n * Controls the color scale of the heatmap\n */\nexport enum HeatmapColorScale {\n  Exponential = 'exponential',\n  Linear = 'linear',\n}\n\n/**\n * Controls which axis to allow selection on\n */\nexport enum HeatmapSelectionMode {\n  X = 'x',\n  Xy = 'xy',\n  Y = 'y',\n}\n\n/**\n * Controls various color options\n */\nexport interface HeatmapColorOptions {\n  /**\n   * Controls the exponent when scale is set to exponential\n   */\n  exponent: number;\n  /**\n   * Controls the color fill when in opacity mode\n   */\n  fill: string;\n  /**\n   * Sets the maximum value for the color scale\n   */\n  max?: number;\n  /**\n   * Sets the minimum value for the color scale\n   */\n  min?: number;\n  /**\n   * Sets the color mode\n   */\n  mode?: HeatmapColorMode;\n  /**\n   * Reverses the color scheme\n   */\n  reverse: boolean;\n  /**\n   * Controls the color scale\n   */\n  scale?: HeatmapColorScale;\n  /**\n   * Controls the color scheme used\n   */\n  scheme: string;\n  /**\n   * Controls the number of color steps\n   */\n  steps: number;\n}\n\n/**\n * Configuration options for the yAxis\n */\nexport interface YAxisConfig extends ui.AxisConfig {\n  /**\n   * Controls the number of decimals for yAxis values\n   */\n  decimals?: number;\n  /**\n   * Sets the maximum value for the yAxis\n   */\n  max?: number;\n  /**\n   * Sets the minimum value for the yAxis\n   */\n  min?: number;\n  /**\n   * Reverses the yAxis\n   */\n  reverse?: boolean;\n  /**\n   * Sets the yAxis unit\n   */\n  unit?: string;\n}\n\n/**\n * Controls cell value options\n */\nexport interface CellValues {\n  /**\n   * Controls the number of decimals for cell values\n   */\n  decimals?: number;\n  /**\n   * Controls the cell value unit\n   */\n  unit?: string;\n}\n\n/**\n * Controls the value filter range\n */\nexport interface FilterValueRange {\n  /**\n   * Sets the filter range to values greater than or equal to the given value\n   */\n  ge?: number;\n  /**\n   * Sets the filter range to values less than or equal to the given value\n   */\n  le?: number;\n}\n\n/**\n * Controls tooltip options\n */\nexport interface HeatmapTooltip {\n  maxHeight?: number;\n  maxWidth?: number;\n  /**\n   * Controls how the tooltip is shown\n   */\n  mode: ui.TooltipDisplayMode;\n  /**\n   * Controls if the tooltip shows a color scale in header\n   */\n  showColorScale?: boolean;\n  /**\n   * Controls if the tooltip shows a histogram of the y-axis values\n   */\n  yHistogram?: boolean;\n}\n\n/**\n * Controls legend options\n */\nexport interface HeatmapLegend {\n  /**\n   * Controls if the legend is shown\n   */\n  show: boolean;\n}\n\n/**\n * Controls exemplar options\n */\nexport interface ExemplarConfig {\n  /**\n   * Sets the color of the exemplar markers\n   */\n  color: string;\n}\n\n/**\n * Controls frame rows options\n */\nexport interface RowsHeatmapOptions {\n  /**\n   * Controls tick alignment when not calculating from data\n   */\n  layout?: ui.HeatmapCellLayout;\n  /**\n   * Sets the name of the cell when not calculating from data\n   */\n  value?: string;\n}\n\nexport interface Options {\n  /**\n   * Controls if the heatmap should be calculated from data\n   */\n  calculate?: boolean;\n  /**\n   * Calculation options for the heatmap\n   */\n  calculation?: ui.HeatmapCalculationOptions;\n  /**\n   * Controls gap between cells\n   */\n  cellGap?: number;\n  /**\n   * Controls cell radius\n   */\n  cellRadius?: number;\n  /**\n   * Controls cell value unit\n   */\n  cellValues?: CellValues;\n  /**\n   * Controls the color options\n   */\n  color: HeatmapColorOptions;\n  /**\n   * Controls exemplar options\n   */\n  exemplars: ExemplarConfig;\n  /**\n   * Filters values between a given range\n   */\n  filterValues?: FilterValueRange;\n  /**\n   * | *{\n   * \taxisPlacement: ui.AxisPlacement & \"left\" // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed\n   * }\n   * Controls legend options\n   */\n  legend: HeatmapLegend;\n  /**\n   * Controls tick alignment and value name when not calculating from data\n   */\n  rowsFrame?: RowsHeatmapOptions;\n  /**\n   * Controls which axis to allow selection on\n   */\n  selectionMode?: HeatmapSelectionMode;\n  /**\n   * | *{\n   * \tlayout: ui.HeatmapCellLayout & \"auto\" // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed\n   * }\n   * Controls the display of the value in the cell\n   */\n  showValue: ui.VisibilityMode;\n  /**\n   * Controls tooltip options\n   */\n  tooltip: HeatmapTooltip;\n  /**\n   * Controls yAxis placement\n   */\n  yAxis: YAxisConfig;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  calculate: false,\n  cellGap: 1,\n  cellValues: {},\n  color: {\n    /**\n     * mode:     HeatmapColorMode // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed\n     */\n    scheme: 'Oranges',\n    fill: 'dark-orange',\n    /**\n     * scale:    HeatmapColorScale // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed\n     */\n    reverse: false,\n    exponent: 0.5,\n    steps: 64,\n  },\n  exemplars: {\n    color: 'rgba(255,0,255,0.7)',\n  },\n  filterValues: {\n    le: 1e-09,\n  },\n  legend: {\n    show: true,\n  },\n  selectionMode: HeatmapSelectionMode.X,\n  showValue: ui.VisibilityMode.Auto,\n  tooltip: {\n    mode: ui.TooltipDisplayMode.Single,\n    yHistogram: false,\n    showColorScale: false,\n  },\n};\n\nexport interface FieldConfig extends ui.HideableFieldConfig {\n  scaleDistribution?: ui.ScaleDistributionConfig;\n}\n","export * from './panelcfg.gen';\n\nimport { AxisPlacement, HeatmapCellLayout } from '@grafana/schema';\n\nimport { defaultOptions as defaultOptionsGen, HeatmapColorMode, HeatmapColorScale, Options } from './panelcfg.gen';\n\nexport const defaultOptions = {\n  ...defaultOptionsGen,\n  color: { ...defaultOptionsGen.color, mode: HeatmapColorMode.Scheme, scale: HeatmapColorScale.Exponential },\n  yAxis: { ...defaultOptionsGen.yAxis, axisPlacement: AxisPlacement.Left },\n  rowsFrame: { ...defaultOptionsGen.rowsFrame, layout: HeatmapCellLayout.auto },\n} as Options;\n","import { RefObject } from 'react';\nimport uPlot, { Cursor } from 'uplot';\n\nimport {\n  DataFrameType,\n  formattedValueToString,\n  getValueFormat,\n  GrafanaTheme2,\n  incrRoundDn,\n  incrRoundUp,\n  TimeRange,\n  FieldType,\n} from '@grafana/data';\nimport { AxisPlacement, ScaleDirection, ScaleDistribution, ScaleOrientation, HeatmapCellLayout } from '@grafana/schema';\nimport { UPlotConfigBuilder } from '@grafana/ui';\nimport { isHeatmapCellsDense, readHeatmapRowsCustomMeta } from 'app/features/transformers/calculateHeatmap/heatmap';\n\nimport { pointWithin, Quadtree, Rect } from '../barchart/quadtree';\n\nimport { HeatmapData } from './fields';\nimport { FieldConfig, HeatmapSelectionMode, YAxisConfig } from './types';\n\ninterface PathbuilderOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n  gap?: number | null;\n  hideLE?: number;\n  hideGE?: number;\n  xAlign?: -1 | 0 | 1;\n  yAlign?: -1 | 0 | 1;\n  ySizeDivisor?: number;\n  disp: {\n    fill: {\n      values: (u: uPlot, seriesIndex: number) => number[];\n      index: Array<CanvasRenderingContext2D['fillStyle']>;\n    };\n  };\n}\n\ninterface PointsBuilderOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n}\n\ninterface PrepConfigOpts {\n  dataRef: RefObject<HeatmapData>;\n  theme: GrafanaTheme2;\n  timeZone: string;\n  getTimeRange: () => TimeRange;\n  exemplarColor: string;\n  cellGap?: number | null; // in css pixels\n  hideLE?: number;\n  hideGE?: number;\n  yAxisConfig: YAxisConfig;\n  ySizeDivisor?: number;\n  selectionMode?: HeatmapSelectionMode;\n}\n\nexport function prepConfig(opts: PrepConfigOpts) {\n  const {\n    dataRef,\n    theme,\n    timeZone,\n    getTimeRange,\n    cellGap,\n    hideLE,\n    hideGE,\n    yAxisConfig,\n    ySizeDivisor,\n    selectionMode = HeatmapSelectionMode.X,\n  } = opts;\n\n  const xScaleKey = 'x';\n  let isTime = true;\n\n  if (dataRef.current?.heatmap?.fields[0].type !== FieldType.time) {\n    isTime = false;\n  }\n\n  const pxRatio = devicePixelRatio;\n\n  let heatmapType = dataRef.current?.heatmap?.meta?.type;\n  const exemplarFillColor = theme.visualization.getColorByName(opts.exemplarColor);\n\n  let qt: Quadtree;\n  let hRect: Rect | null;\n\n  let builder = new UPlotConfigBuilder(timeZone);\n\n  builder.addHook('init', (u) => {\n    u.root.querySelectorAll<HTMLElement>('.u-cursor-pt').forEach((el) => {\n      Object.assign(el.style, {\n        borderRadius: '0',\n        border: '1px solid white',\n        background: 'transparent',\n      });\n    });\n  });\n\n  if (isTime) {\n    // this is a tmp hack because in mode: 2, uplot does not currently call scales.x.range() for setData() calls\n    // scales.x.range() typically reads back from drilled-down panelProps.timeRange via getTimeRange()\n    builder.addHook('setData', (u) => {\n      //let [min, max] = (u.scales!.x!.range! as uPlot.Range.Function)(u, 0, 100, xScaleKey);\n\n      let { min: xMin, max: xMax } = u.scales!.x;\n\n      let min = getTimeRange().from.valueOf();\n      let max = getTimeRange().to.valueOf();\n\n      if (xMin !== min || xMax !== max) {\n        queueMicrotask(() => {\n          u.setScale(xScaleKey, { min, max });\n        });\n      }\n    });\n  }\n\n  builder.addHook('drawClear', (u) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s, i) => {\n      if (i > 0) {\n        // @ts-ignore\n        s._paths = null;\n      }\n    });\n  });\n\n  builder.setMode(2);\n\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    // TODO: expand by x bucket size and layout\n    range: (u, dataMin, dataMax) => {\n      if (isTime) {\n        return [getTimeRange().from.valueOf(), getTimeRange().to.valueOf()];\n      } else {\n        if (dataRef.current?.xLayout === HeatmapCellLayout.le) {\n          return [dataMin - dataRef.current?.xBucketSize!, dataMax];\n        } else if (dataRef.current?.xLayout === HeatmapCellLayout.ge) {\n          return [dataMin, dataMax + dataRef.current?.xBucketSize!];\n        } else {\n          let offset = dataRef.current?.xBucketSize! / 2;\n\n          return [dataMin - offset, dataMax + offset];\n        }\n      }\n    },\n  });\n\n  let incrs;\n\n  if (!isTime) {\n    incrs = [];\n\n    for (let i = 0; i < 10; i++) {\n      incrs.push(i * dataRef.current?.xBucketSize!);\n    }\n  }\n\n  builder.addAxis({\n    scaleKey: xScaleKey,\n    placement: AxisPlacement.Bottom,\n    incrs,\n    isTime,\n    theme: theme,\n    timeZone,\n  });\n\n  const yField = dataRef.current?.heatmap?.fields[1]!;\n  if (!yField) {\n    return builder; // early abort (avoids error)\n  }\n\n  const yFieldConfig: FieldConfig | undefined = yField.config?.custom;\n  const yScale = yFieldConfig?.scaleDistribution ?? { type: ScaleDistribution.Linear };\n  const yAxisReverse = Boolean(yAxisConfig.reverse);\n  const isSparseHeatmap = heatmapType === DataFrameType.HeatmapCells && !isHeatmapCellsDense(dataRef.current?.heatmap!);\n  const shouldUseLogScale = yScale.type !== ScaleDistribution.Linear || isSparseHeatmap;\n  const isOrdinalY = readHeatmapRowsCustomMeta(dataRef.current?.heatmap).yOrdinalDisplay != null;\n\n  // random to prevent syncing y in other heatmaps\n  // TODO: try to match TimeSeries y keygen algo to sync with TimeSeries panels (when not isOrdinalY)\n  const yScaleKey = 'y_' + (Math.random() + 1).toString(36).substring(7);\n\n  builder.addScale({\n    scaleKey: yScaleKey,\n    isTime: false,\n    // distribution: ScaleDistribution.Ordinal, // does not work with facets/scatter yet\n    orientation: ScaleOrientation.Vertical,\n    direction: yAxisReverse ? ScaleDirection.Down : ScaleDirection.Up,\n    // should be tweakable manually\n    distribution: shouldUseLogScale ? ScaleDistribution.Log : ScaleDistribution.Linear,\n    log: yScale.log ?? 2,\n    range:\n      // sparse already accounts for le/ge by explicit yMin & yMax cell bounds, so no need to expand y range\n      isSparseHeatmap\n        ? (u, dataMin, dataMax) => {\n            // ...but uPlot currently only auto-ranges from the yMin facet data, so we have to grow by 1 extra factor\n            // @ts-ignore\n            let bucketFactor = u.data[1][2][0] / u.data[1][1][0];\n\n            dataMax *= bucketFactor;\n\n            let scaleMin: number | null, scaleMax: number | null;\n\n            [scaleMin, scaleMax] = shouldUseLogScale\n              ? uPlot.rangeLog(dataMin, dataMax, (yScale.log ?? 2) as unknown as uPlot.Scale.LogBase, true)\n              : [dataMin, dataMax];\n\n            if (shouldUseLogScale && !isOrdinalY) {\n              let yExp = u.scales[yScaleKey].log!;\n              let log = yExp === 2 ? Math.log2 : Math.log10;\n\n              let { min: explicitMin, max: explicitMax } = yAxisConfig;\n\n              // guard against <= 0\n              if (explicitMin != null && explicitMin > 0) {\n                // snap to magnitude\n                let minLog = log(explicitMin);\n                scaleMin = yExp ** incrRoundDn(minLog, 1);\n              }\n\n              if (explicitMax != null && explicitMax > 0) {\n                let maxLog = log(explicitMax);\n                scaleMax = yExp ** incrRoundUp(maxLog, 1);\n              }\n            }\n\n            return [scaleMin, scaleMax];\n          }\n        : // dense and ordinal only have one of yMin|yMax|y, so expand range by one cell in the direction of le/ge/unknown\n          (u, dataMin, dataMax) => {\n            let scaleMin = dataMin,\n              scaleMax = dataMax;\n\n            let { min: explicitMin, max: explicitMax } = yAxisConfig;\n\n            // logarithmic expansion\n            if (shouldUseLogScale) {\n              let yExp = u.scales[yScaleKey].log!;\n\n              let minExpanded = false;\n              let maxExpanded = false;\n\n              let log = yExp === 2 ? Math.log2 : Math.log10;\n\n              if (ySizeDivisor !== 1) {\n                let minLog = log(dataMin);\n                let maxLog = log(dataMax);\n\n                if (!Number.isInteger(minLog)) {\n                  scaleMin = yExp ** incrRoundDn(minLog, 1);\n                  minExpanded = true;\n                }\n\n                if (!Number.isInteger(maxLog)) {\n                  scaleMax = yExp ** incrRoundUp(maxLog, 1);\n                  maxExpanded = true;\n                }\n              }\n\n              if (dataRef.current?.yLayout === HeatmapCellLayout.le) {\n                if (!minExpanded) {\n                  scaleMin /= yExp;\n                }\n              } else if (dataRef.current?.yLayout === HeatmapCellLayout.ge) {\n                if (!maxExpanded) {\n                  scaleMax *= yExp;\n                }\n              } else {\n                scaleMin /= yExp / 2;\n                scaleMax *= yExp / 2;\n              }\n\n              if (!isOrdinalY) {\n                // guard against <= 0\n                if (explicitMin != null && explicitMin > 0) {\n                  // snap down to magnitude\n                  let minLog = log(explicitMin);\n                  scaleMin = yExp ** incrRoundDn(minLog, 1);\n                }\n\n                if (explicitMax != null && explicitMax > 0) {\n                  let maxLog = log(explicitMax);\n                  scaleMax = yExp ** incrRoundUp(maxLog, 1);\n                }\n              }\n            }\n            // linear expansion\n            else {\n              let bucketSize = dataRef.current?.yBucketSize;\n\n              if (bucketSize === 0) {\n                bucketSize = 1;\n              }\n\n              if (bucketSize) {\n                if (dataRef.current?.yLayout === HeatmapCellLayout.le) {\n                  scaleMin -= bucketSize!;\n                } else if (dataRef.current?.yLayout === HeatmapCellLayout.ge) {\n                  scaleMax += bucketSize!;\n                } else {\n                  scaleMin -= bucketSize! / 2;\n                  scaleMax += bucketSize! / 2;\n                }\n              } else {\n                // how to expand scale range if inferred non-regular or log buckets?\n              }\n\n              if (!isOrdinalY) {\n                scaleMin = explicitMin ?? scaleMin;\n                scaleMax = explicitMax ?? scaleMax;\n              }\n            }\n\n            return [scaleMin, scaleMax];\n          },\n  });\n\n  const dispY = yField.display ?? getValueFormat('short');\n\n  builder.addAxis({\n    scaleKey: yScaleKey,\n    show: yAxisConfig.axisPlacement !== AxisPlacement.Hidden,\n    placement: yAxisConfig.axisPlacement || AxisPlacement.Left,\n    size: yAxisConfig.axisWidth || null,\n    label: yAxisConfig.axisLabel,\n    theme: theme,\n    formatValue: (v, decimals) => formattedValueToString(dispY(v, decimals)),\n    splits: isOrdinalY\n      ? (self: uPlot) => {\n          const meta = readHeatmapRowsCustomMeta(dataRef.current?.heatmap);\n          if (!meta.yOrdinalDisplay) {\n            return [0, 1]; //?\n          }\n          let splits = meta.yOrdinalDisplay.map((v, idx) => idx);\n\n          switch (dataRef.current?.yLayout) {\n            case HeatmapCellLayout.le:\n              splits.unshift(-1);\n              break;\n            case HeatmapCellLayout.ge:\n              splits.push(splits.length);\n              break;\n          }\n\n          // Skip labels when the height is too small\n          if (self.height < 60) {\n            splits = [splits[0], splits[splits.length - 1]];\n          } else {\n            while (splits.length > 3 && (self.height - 15) / splits.length < 10) {\n              splits = splits.filter((v, idx) => idx % 2 === 0); // remove half the items\n            }\n          }\n          return splits;\n        }\n      : undefined,\n    values: isOrdinalY\n      ? (self: uPlot, splits) => {\n          const meta = readHeatmapRowsCustomMeta(dataRef.current?.heatmap);\n          if (meta.yOrdinalDisplay) {\n            return splits.map((v) =>\n              v < 0\n                ? (meta.yMinDisplay ?? '') // Check prometheus style labels\n                : (meta.yOrdinalDisplay[v] ?? '')\n            );\n          }\n          return splits;\n        }\n      : undefined,\n  });\n\n  const pathBuilder = isSparseHeatmap ? heatmapPathsSparse : heatmapPathsDense;\n\n  // heatmap layer\n  builder.addSeries({\n    facets: [\n      {\n        scale: xScaleKey,\n        auto: true,\n        sorted: 1,\n      },\n      {\n        scale: yScaleKey,\n        auto: true,\n      },\n    ],\n    pathBuilder: pathBuilder({\n      each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n        qt.add({\n          x: x - u.bbox.left,\n          y: y - u.bbox.top,\n          w: xSize,\n          h: ySize,\n          sidx: seriesIdx,\n          didx: dataIdx,\n        });\n      },\n      gap: cellGap,\n      hideLE,\n      hideGE,\n      xAlign:\n        dataRef.current?.xLayout === HeatmapCellLayout.le\n          ? -1\n          : dataRef.current?.xLayout === HeatmapCellLayout.ge\n            ? 1\n            : 0,\n      yAlign: ((dataRef.current?.yLayout === HeatmapCellLayout.le\n        ? -1\n        : dataRef.current?.yLayout === HeatmapCellLayout.ge\n          ? 1\n          : 0) * (yAxisReverse ? -1 : 1)) as -1 | 0 | 1,\n      ySizeDivisor,\n      disp: {\n        fill: {\n          values: (u, seriesIdx) => dataRef.current?.heatmapColors?.values!,\n          index: dataRef.current?.heatmapColors?.palette!,\n        },\n      },\n    }),\n    theme,\n    scaleKey: '', // facets' scales used (above)\n  });\n\n  // exemplars layer\n  builder.addSeries({\n    facets: [\n      {\n        scale: xScaleKey,\n        auto: true,\n        sorted: 1,\n      },\n      {\n        scale: yScaleKey,\n        auto: true,\n      },\n    ],\n    pathBuilder: heatmapPathsPoints(\n      {\n        each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n          qt.add({\n            x: x - u.bbox.left,\n            y: y - u.bbox.top,\n            w: xSize,\n            h: ySize,\n            sidx: seriesIdx,\n            didx: dataIdx,\n          });\n        },\n      },\n      exemplarFillColor,\n      dataRef.current.yLayout\n    ),\n    theme,\n    scaleKey: '', // facets' scales used (above)\n  });\n\n  const dragX = selectionMode === HeatmapSelectionMode.X || selectionMode === HeatmapSelectionMode.Xy;\n  const dragY = selectionMode === HeatmapSelectionMode.Y || selectionMode === HeatmapSelectionMode.Xy;\n\n  const cursor: Cursor = {\n    drag: {\n      x: dragX,\n      y: dragY,\n      setScale: false,\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        hRect = null;\n\n        let cx = u.cursor.left! * pxRatio;\n        let cy = u.cursor.top! * pxRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = o;\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    focus: {\n      prox: 1e3,\n      dist: (u, seriesIdx) => (hRect?.sidx === seriesIdx ? 0 : Infinity),\n    },\n    points: {\n      fill: 'rgba(255,255,255, 0.3)',\n      bbox: (u, seriesIdx) => {\n        let isHovered = hRect && seriesIdx === hRect.sidx;\n\n        return {\n          left: isHovered ? hRect!.x / pxRatio : -10,\n          top: isHovered ? hRect!.y / pxRatio : -10,\n          width: isHovered ? hRect!.w / pxRatio : 0,\n          height: isHovered ? hRect!.h / pxRatio : 0,\n        };\n      },\n    },\n  };\n\n  builder.setCursor(cursor);\n\n  return builder;\n}\n\nconst CRISP_EDGES_GAP_MIN = 4;\n\nexport function heatmapPathsDense(opts: PathbuilderOpts) {\n  const { disp, each, gap = 1, hideLE = -Infinity, hideGE = Infinity, xAlign = 1, yAlign = 1, ySizeDivisor = 1 } = opts;\n\n  const pxRatio = devicePixelRatio;\n\n  const round = gap! >= CRISP_EDGES_GAP_MIN ? Math.round : (v: number) => v;\n\n  const cellGap = Math.round(gap! * pxRatio);\n\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        let d = u.data[seriesIdx];\n        const xs = d[0] as unknown as number[];\n        const ys = d[1] as unknown as number[];\n        const counts = d[2] as unknown as number[];\n        const dlen = xs.length;\n\n        // fill colors are mapped from interpolating densities / counts along some gradient\n        // (should be quantized to 64 colors/levels max. e.g. 16)\n        let fills = disp.fill.values(u, seriesIdx);\n        let fillPalette = disp.fill.index ?? [...new Set(fills)];\n\n        let fillPaths = fillPalette.map((color) => new Path2D());\n\n        // detect x and y bin qtys by detecting layout repetition in x & y data\n        let yBinQty = dlen - ys.lastIndexOf(ys[0]);\n        let xBinQty = dlen / yBinQty;\n        let yBinIncr = ys[1] - ys[0] || scaleY.max! - scaleY.min!;\n        let xBinIncr = xs[yBinQty] - xs[0];\n\n        // uniform tile sizes based on zoom level\n        let xSize: number;\n        let ySize: number;\n\n        if (scaleX.distr === 3) {\n          xSize = Math.abs(valToPosX(xs[0] * scaleX.log!, scaleX, xDim, xOff) - valToPosX(xs[0], scaleX, xDim, xOff));\n        } else {\n          xSize = Math.abs(valToPosX(xBinIncr, scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff));\n        }\n\n        if (scaleY.distr === 3) {\n          ySize =\n            Math.abs(valToPosY(ys[0] * scaleY.log!, scaleY, yDim, yOff) - valToPosY(ys[0], scaleY, yDim, yOff)) /\n            ySizeDivisor;\n        } else {\n          ySize = Math.abs(valToPosY(yBinIncr, scaleY, yDim, yOff) - valToPosY(0, scaleY, yDim, yOff)) / ySizeDivisor;\n        }\n\n        // clamp min tile size to 1px\n        xSize = Math.max(1, round(xSize - cellGap));\n        ySize = Math.max(1, round(ySize - cellGap));\n\n        // bucket agg direction\n        // let xCeil = false;\n        // let yCeil = false;\n\n        let xOffset = xAlign === -1 ? -xSize : xAlign === 0 ? -xSize / 2 : 0;\n        let yOffset = yAlign === 1 ? -ySize : yAlign === 0 ? -ySize / 2 : 0;\n\n        // pre-compute x and y offsets\n        let cys = ys.slice(0, yBinQty).map((y) => round(valToPosY(y, scaleY, yDim, yOff) + yOffset));\n        let cxs = Array.from({ length: xBinQty }, (v, i) =>\n          round(valToPosX(xs[i * yBinQty], scaleX, xDim, xOff) + xOffset)\n        );\n\n        for (let i = 0; i < dlen; i++) {\n          if (counts[i] != null && counts[i] > hideLE && counts[i] < hideGE) {\n            let cx = cxs[~~(i / yBinQty)];\n            let cy = cys[i % yBinQty];\n\n            let fillPath = fillPaths[fills[i]];\n\n            rect(fillPath, cx, cy, xSize, ySize);\n\n            each(u, 1, i, cx, cy, xSize, ySize);\n          }\n        }\n\n        u.ctx.save();\n        //\tu.ctx.globalAlpha = 0.8;\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n\n        return null;\n      }\n    );\n\n    return null;\n  };\n}\n\nexport function heatmapPathsPoints(opts: PointsBuilderOpts, exemplarColor: string, yLayout?: HeatmapCellLayout) {\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        //console.time('heatmapPathsSparse');\n\n        let points = new Path2D();\n        let fillPaths = [points];\n        let fillPalette = [exemplarColor ?? 'rgba(255,0,255,0.7)'];\n\n        let yShift = yLayout === HeatmapCellLayout.le ? -0.5 : yLayout === HeatmapCellLayout.ge ? 0.5 : 0;\n\n        for (let i = 0; i < dataX.length; i++) {\n          let yVal = dataY[i]!;\n\n          // this is a hacky by-proxy check\n          // works okay since we have no exemplars in calculated heatmaps and...\n          //  - heatmap-rows has ordinal y\n          //  - heatmap-cells has log2 y\n          let isSparseHeatmap = scaleY.distr === 3 && scaleY.log === 2;\n\n          if (!isSparseHeatmap) {\n            yVal += yShift;\n          }\n\n          let x = valToPosX(dataX[i], scaleX, xDim, xOff);\n          let y = valToPosY(yVal, scaleY, yDim, yOff);\n          let w = 8;\n          let h = 8;\n\n          rect(points, x - w / 2, y - h / 2, w, h);\n\n          opts.each(u, seriesIdx, i, x - w / 2, y - h / 2, w, h);\n        }\n\n        u.ctx.save();\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n      }\n    );\n\n    return null;\n  };\n}\n// accepts xMax, yMin, yMax, count\n// xbinsize? x tile sizes are uniform?\nexport function heatmapPathsSparse(opts: PathbuilderOpts) {\n  const { disp, each, gap = 1, hideLE = -Infinity, hideGE = Infinity } = opts;\n\n  const pxRatio = devicePixelRatio;\n\n  const round = gap! >= CRISP_EDGES_GAP_MIN ? Math.round : (v: number) => v;\n\n  const cellGap = Math.round(gap! * pxRatio);\n\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        //console.time('heatmapPathsSparse');\n\n        let d = u.data[seriesIdx];\n        const xMaxs = d[0] as unknown as number[]; // xMax, do we get interval?\n        const yMins = d[1] as unknown as number[];\n        const yMaxs = d[2] as unknown as number[];\n        const counts = d[3] as unknown as number[];\n        const dlen = xMaxs.length;\n\n        // fill colors are mapped from interpolating densities / counts along some gradient\n        // (should be quantized to 64 colors/levels max. e.g. 16)\n        let fills = disp.fill.values(u, seriesIdx);\n        let fillPalette = disp.fill.index ?? [...new Set(fills)];\n\n        let fillPaths = fillPalette.map((color) => new Path2D());\n\n        // cache all tile bounds\n        let xOffs = new Map();\n        let yOffs = new Map();\n\n        for (let i = 0; i < xMaxs.length; i++) {\n          let xMax = xMaxs[i];\n          let yMin = yMins[i];\n          let yMax = yMaxs[i];\n\n          if (!xOffs.has(xMax)) {\n            xOffs.set(xMax, round(valToPosX(xMax, scaleX, xDim, xOff)));\n          }\n\n          if (!yOffs.has(yMin)) {\n            yOffs.set(yMin, round(valToPosY(yMin, scaleY, yDim, yOff)));\n          }\n\n          if (!yOffs.has(yMax)) {\n            yOffs.set(yMax, round(valToPosY(yMax, scaleY, yDim, yOff)));\n          }\n        }\n\n        // uniform x size (interval, step)\n        let xSizeUniform = xOffs.get(xMaxs.find((v) => v !== xMaxs[0])) - xOffs.get(xMaxs[0]);\n\n        for (let i = 0; i < dlen; i++) {\n          if (counts[i] <= hideLE || counts[i] >= hideGE) {\n            continue;\n          }\n\n          let xMax = xMaxs[i];\n          let yMin = yMins[i];\n          let yMax = yMaxs[i];\n\n          let xMaxPx = xOffs.get(xMax); // xSize is from interval, or inferred delta?\n          let yMinPx = yOffs.get(yMin);\n          let yMaxPx = yOffs.get(yMax);\n\n          let xSize = xSizeUniform;\n          let ySize = yMinPx - yMaxPx;\n\n          // clamp min tile size to 1px\n          xSize = Math.max(1, xSize - cellGap);\n          ySize = Math.max(1, ySize - cellGap);\n\n          let x = xMaxPx - cellGap / 2 - xSize;\n          let y = yMaxPx + cellGap / 2;\n\n          let fillPath = fillPaths[fills[i]];\n\n          rect(fillPath, x, y, xSize, ySize);\n\n          each(u, 1, i, x, y, xSize, ySize);\n        }\n\n        u.ctx.save();\n        //\tu.ctx.globalAlpha = 0.8;\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n\n        //console.timeEnd('heatmapPathsSparse');\n      }\n    );\n\n    return null;\n  };\n}\n\nexport const boundedMinMax = (\n  values: number[],\n  minValue?: number,\n  maxValue?: number,\n  hideLE = -Infinity,\n  hideGE = Infinity\n) => {\n  if (minValue == null) {\n    minValue = Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] != null && values[i] > hideLE && values[i] < hideGE) {\n        minValue = Math.min(minValue, values[i]);\n      }\n    }\n  }\n\n  if (maxValue == null) {\n    maxValue = -Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] != null && values[i] > hideLE && values[i] < hideGE) {\n        maxValue = Math.max(maxValue, values[i]);\n      }\n    }\n  }\n\n  return [minValue, maxValue];\n};\n\nexport const valuesToFills = (values: number[], palette: string[], minValue: number, maxValue: number): number[] => {\n  let range = maxValue - minValue || 1;\n\n  let paletteSize = palette.length;\n\n  let indexedFills = Array(values.length);\n\n  for (let i = 0; i < values.length; i++) {\n    indexedFills[i] =\n      values[i] < minValue\n        ? 0\n        : values[i] > maxValue\n          ? paletteSize - 1\n          : Math.min(paletteSize - 1, Math.floor((paletteSize * (values[i] - minValue)) / range));\n  }\n\n  return indexedFills;\n};\n"],"names":["MAX_OBJECTS","MAX_LEVELS","pointWithin","px","py","rlft","rtop","rrgt","rbtm","findRects","qt","sidx","didx","rects","rect","i","intersects","r1","r2","Quadtree","x","y","w","h","l","t","cb","q","hzMid","vtMid","startIsNorth","startIsWest","endIsEast","endIsSouth","o","os","oi","HeatmapColorMode","HeatmapColorScale","HeatmapSelectionMode","defaultOptions","prepConfig","opts","dataRef","theme","timeZone","getTimeRange","cellGap","hideLE","hideGE","yAxisConfig","ySizeDivisor","selectionMode","xScaleKey","isTime","pxRatio","heatmapType","exemplarFillColor","hRect","builder","u","el","xMin","xMax","min","max","s","dataMin","dataMax","offset","incrs","yField","yScale","yAxisReverse","isSparseHeatmap","shouldUseLogScale","isOrdinalY","yScaleKey","bucketFactor","scaleMin","scaleMax","yExp","log","explicitMin","explicitMax","minLog","maxLog","minExpanded","maxExpanded","bucketSize","dispY","v","decimals","self","meta","splits","idx","pathBuilder","heatmapPathsSparse","heatmapPathsDense","seriesIdx","dataIdx","xSize","ySize","heatmapPathsPoints","dragX","dragY","cursor","cx","cy","isHovered","CRISP_EDGES_GAP_MIN","disp","each","gap","xAlign","yAlign","round","series","dataX","dataY","scaleX","scaleY","valToPosX","valToPosY","xOff","yOff","xDim","yDim","moveTo","lineTo","arc","d","xs","ys","counts","dlen","fills","fillPalette","fillPaths","color","yBinQty","xBinQty","yBinIncr","xBinIncr","xOffset","yOffset","cys","cxs","fillPath","p","exemplarColor","yLayout","points","yShift","yVal","xMaxs","yMins","yMaxs","xOffs","yOffs","yMin","yMax","xSizeUniform","xMaxPx","yMinPx","yMaxPx","boundedMinMax","values","minValue","maxValue","valuesToFills","palette","range","paletteSize","indexedFills"],"sourceRoot":""}