{"version":3,"file":"barChartPanel.2479ed24a2aca8e31093.js","mappings":"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","sources":["webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipWrapper.tsx","webpack://grafana/./public/app/plugins/panel/barchart/BarChartLegend.tsx","webpack://grafana/./public/app/plugins/panel/barchart/bars.ts","webpack://grafana/./public/app/plugins/panel/barchart/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/barchart/utils.ts","webpack://grafana/./public/app/plugins/panel/barchart/BarChartPanel.tsx","webpack://grafana/./public/app/plugins/panel/barchart/TickSpacingEditor.tsx","webpack://grafana/./public/app/plugins/panel/barchart/migrations.ts","webpack://grafana/./public/app/plugins/panel/barchart/suggestions.ts","webpack://grafana/./public/app/plugins/panel/barchart/module.tsx","webpack://grafana/./public/app/plugins/panel/timeseries/TimeSeriesTooltip.tsx","webpack://grafana/./public/app/plugins/panel/timeseries/utils.ts","webpack://grafana/./public/app/plugins/panel/xychart/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/xychart/utils.ts"],"sourcesContent":["import { css, cx } from '@emotion/css';\nimport React, { HTMLAttributes } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes';\n\nexport interface Props extends HTMLAttributes<HTMLDivElement> {\n  children?: React.ReactNode;\n}\n\nexport const VizTooltipWrapper = ({ children, className }: Props) => {\n  const styles = useStyles2(getStyles);\n\n  return <div className={cx(styles.wrapper, className)}>{children}</div>;\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    display: 'flex',\n    flexDirection: 'column',\n    fontSize: theme.typography.bodySmall.fontSize,\n  }),\n});\n","import { includes } from 'lodash';\nimport { memo } from 'react';\n\nimport {\n  DataFrame,\n  Field,\n  FieldColorModeId,\n  getFieldSeriesColor,\n  ThresholdsConfig,\n  ThresholdsMode,\n  ValueMapping,\n} from '@grafana/data';\nimport { VizLegendOptions, AxisPlacement } from '@grafana/schema';\nimport { UPlotConfigBuilder, VizLayout, VizLayoutLegendProps, VizLegend, VizLegendItem, useTheme2 } from '@grafana/ui';\nimport { getDisplayValuesForCalcs } from '@grafana/ui/internal';\nimport { getThresholdItems, getValueMappingItems } from 'app/core/components/TimelineChart/utils';\ninterface BarChartLegend2Props extends VizLegendOptions, Omit<VizLayoutLegendProps, 'children'> {\n  data: DataFrame[];\n  colorField?: Field | null;\n  // config: UPlotConfigBuilder;\n}\n\n/**\n * mostly duplicates logic in PlotLegend below :(\n *\n * @internal\n */\nexport function hasVisibleLegendSeries(config: UPlotConfigBuilder, data: DataFrame[]) {\n  return data[0].fields.slice(1).some((field) => !Boolean(field.config.custom?.hideFrom?.legend));\n\n  // return config.getSeries().some((s, i) => {\n  //   const frameIndex = 0;\n  //   const fieldIndex = i + 1;\n  //   const field = data[frameIndex].fields[fieldIndex];\n  //   return !Boolean(field.config.custom?.hideFrom?.legend);\n  // });\n}\n\nexport const BarChartLegend = memo(\n  ({ data, placement, calcs, displayMode, colorField, ...vizLayoutLegendProps }: BarChartLegend2Props) => {\n    const theme = useTheme2();\n\n    const fieldConfig = data[0].fields[0].config;\n    const colorMode = fieldConfig.color?.mode;\n\n    const thresholdItems: VizLegendItem[] = [];\n    if (colorMode === FieldColorModeId.Thresholds) {\n      const thresholdsAbsolute: ThresholdsConfig = { mode: ThresholdsMode.Absolute, steps: [] };\n      const thresholdsPercent: ThresholdsConfig = { mode: ThresholdsMode.Percentage, steps: [] };\n\n      for (let i = 1; i < data[0].fields.length; i++) {\n        const field = data[0].fields[i];\n        // there is no reason to add threshold with only one (Base) step\n        if (field.config.thresholds && field.config.thresholds.steps.length > 1) {\n          if (field.config.thresholds.mode === ThresholdsMode.Absolute) {\n            for (const step of field.config.thresholds.steps) {\n              if (!includes(thresholdsAbsolute.steps, step)) {\n                thresholdsAbsolute.steps.push(step);\n              }\n            }\n          } else {\n            for (const step of field.config.thresholds.steps) {\n              if (!includes(thresholdsPercent.steps, step)) {\n                thresholdsPercent.steps.push(step);\n              }\n            }\n          }\n        }\n      }\n\n      const thresholdAbsoluteItems: VizLegendItem[] = getThresholdItems(fieldConfig, theme, thresholdsAbsolute);\n      const thresholdPercentItems: VizLegendItem[] = getThresholdItems(fieldConfig, theme, thresholdsPercent);\n      thresholdItems.push(...thresholdAbsoluteItems, ...thresholdPercentItems);\n    }\n\n    const valueMappings: ValueMapping[] = [];\n    for (let i = 1; i < data[0].fields.length; i++) {\n      const mappings = data[0].fields[i].config.mappings;\n      if (mappings) {\n        for (const mapping of mappings) {\n          if (!includes(valueMappings, mapping)) {\n            valueMappings.push(mapping);\n          }\n        }\n      }\n    }\n    const valueMappingItems: VizLegendItem[] = getValueMappingItems(valueMappings, theme);\n\n    const legendItems = data[0].fields\n      .slice(1)\n      .map((field, i) => {\n        const frameIndex = 0;\n        const fieldIndex = i + 1;\n        // const axisPlacement = config.getAxisPlacement(s.props.scaleKey); // TODO: this should be stamped on the field.config?\n        // const field = data[frameIndex].fields[fieldIndex];\n\n        if (!field || field.config.custom?.hideFrom?.legend) {\n          return undefined;\n        }\n\n        // // apparently doing a second pass like this will take existing state.displayName, and if same as another one, appends counter\n        // const label = getFieldDisplayName(field, data[0], data);\n        const label = field.state?.displayName ?? field.name;\n\n        const color = getFieldSeriesColor(field, theme).color;\n\n        const item: VizLegendItem = {\n          disabled: field.state?.hideFrom?.viz,\n          color,\n          label,\n          yAxis: field.config.custom?.axisPlacement === AxisPlacement.Right ? 2 : 1,\n          getDisplayValues: () => getDisplayValuesForCalcs(calcs, field, theme),\n          getItemKey: () => `${label}-${frameIndex}-${fieldIndex}`,\n        };\n\n        return item;\n      })\n      .filter((i): i is VizLegendItem => i !== undefined);\n\n    return (\n      <VizLayout.Legend placement={placement} {...vizLayoutLegendProps}>\n        <VizLegend\n          placement={placement}\n          items={legendItems}\n          thresholdItems={thresholdItems}\n          mappingItems={valueMappingItems}\n          displayMode={displayMode}\n          sortBy={vizLayoutLegendProps.sortBy}\n          sortDesc={vizLayoutLegendProps.sortDesc}\n          isSortable={true}\n        />\n      </VizLayout.Legend>\n    );\n  }\n);\n\nBarChartLegend.displayName = 'BarChartLegend';\n","import uPlot, { Axis, AlignedData, Scale } from 'uplot';\n\nimport { colorManipulator, DataFrame, dateTimeFormat, GrafanaTheme2, systemDateFormats, TimeZone } from '@grafana/data';\nimport {\n  StackingMode,\n  VisibilityMode,\n  ScaleDirection,\n  ScaleOrientation,\n  VizTextDisplayOptions,\n  VizLegendOptions,\n} from '@grafana/schema';\nimport { measureText } from '@grafana/ui';\nimport { timeUnitSize, StackingGroup, preparePlotData2 } from '@grafana/ui/internal';\n\nconst intervals = systemDateFormats.interval;\n\nimport { distribute, SPACE_BETWEEN } from './distribute';\nimport { findRects, intersects, pointWithin, Quadtree, Rect } from './quadtree';\n\nconst groupDistr = SPACE_BETWEEN;\nconst barDistr = SPACE_BETWEEN;\n// min.max font size for value label\nconst VALUE_MIN_FONT_SIZE = 8;\nconst VALUE_MAX_FONT_SIZE = 30;\n// % of width/height of the bar that value should fit in when measuring size\nconst BAR_FONT_SIZE_RATIO = 0.65;\n// distance between label and a bar in % of bar width\nconst LABEL_OFFSET_FACTOR_VT = 0.1;\nconst LABEL_OFFSET_FACTOR_HZ = 0.15;\n// max distance\nconst LABEL_OFFSET_MAX_VT = 5;\nconst LABEL_OFFSET_MAX_HZ = 10;\n\n// text baseline middle runs through the middle of lowercase letters\n// since bar values are numbers and uppercase-like, we want the middle of uppercase\n// this is a cheap fudge factor that skips expensive and inconsistent cross-browser measuring\nconst MIDDLE_BASELINE_SHIFT = 0.1;\n\n/**\n * @internal\n */\nexport interface BarsOptions {\n  xOri: ScaleOrientation;\n  xDir: ScaleDirection;\n  groupWidth: number;\n  barWidth: number;\n  barRadius: number;\n  showValue: VisibilityMode;\n  stacking: StackingMode;\n  rawValue: (seriesIdx: number, valueIdx: number) => number | null;\n  getColor?: (seriesIdx: number, valueIdx: number, value: unknown) => string | null;\n  fillOpacity?: number;\n  formatValue: (seriesIdx: number, value: unknown) => string;\n  formatShortValue: (seriesIdx: number, value: unknown) => string;\n  timeZone?: TimeZone;\n  text?: VizTextDisplayOptions;\n  hoverMulti?: boolean;\n  legend?: VizLegendOptions;\n  xSpacing?: number;\n  xTimeAuto?: boolean;\n  negY?: boolean[];\n  fullHighlight?: boolean;\n}\n\n/**\n * @internal\n */\ninterface ValueLabelTable {\n  [index: number]: ValueLabelArray;\n}\n\n/**\n * @internal\n */\ninterface ValueLabelArray {\n  [index: number]: ValueLabel;\n}\n\n/**\n * @internal\n */\ninterface ValueLabel {\n  text: string;\n  value: number | null;\n  hidden: boolean;\n  bbox?: Rect;\n  textMetrics?: TextMetrics;\n  x?: number;\n  y?: number;\n}\n\n/**\n * @internal\n */\nfunction calculateFontSizeWithMetrics(\n  text: string,\n  width: number,\n  height: number,\n  lineHeight: number,\n  maxSize?: number\n) {\n  // calculate width in 14px\n  const textSize = measureText(text, 14);\n  // how much bigger than 14px can we make it while staying within our width constraints\n  const fontSizeBasedOnWidth = (width / (textSize.width + 2)) * 14;\n  const fontSizeBasedOnHeight = height / lineHeight;\n\n  // final fontSize\n  const optimalSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);\n  return {\n    fontSize: Math.min(optimalSize, maxSize ?? optimalSize),\n    textMetrics: textSize,\n  };\n}\n\n/**\n * @internal\n */\nexport function getConfig(opts: BarsOptions, theme: GrafanaTheme2) {\n  const {\n    xOri,\n    xDir: dir,\n    rawValue,\n    getColor,\n    formatValue,\n    formatShortValue,\n    fillOpacity = 1,\n    showValue,\n    xSpacing = 0,\n    hoverMulti = false,\n    timeZone = 'browser',\n  } = opts;\n  const isXHorizontal = xOri === ScaleOrientation.Horizontal;\n  const hasAutoValueSize = !Boolean(opts.text?.valueSize);\n  const isStacked = opts.stacking !== StackingMode.None;\n  const pctStacked = opts.stacking === StackingMode.Percent;\n\n  let { groupWidth, barWidth, barRadius = 0 } = opts;\n\n  if (isStacked) {\n    [groupWidth, barWidth] = [barWidth, groupWidth];\n  }\n\n  let qt: Quadtree;\n  const numSeries = 30; // !!\n  const hovered: Array<Rect | null> = Array(numSeries).fill(null);\n  let hRect: Rect | null;\n\n  // for distr: 2 scales, the splits array should contain indices into data[0] rather than values\n  const xSplits: Axis.Splits | undefined = (u) => Array.from(u.data[0].map((v, i) => i));\n\n  const hFilter: Axis.Filter | undefined =\n    xSpacing === 0\n      ? undefined\n      : (u, splits) => {\n          // hSpacing?\n          const dim = u.bbox.width;\n          const _dir = dir * (isXHorizontal ? 1 : -1);\n\n          let dataLen = splits.length;\n          let lastIdx = dataLen - 1;\n\n          let skipMod = 0;\n\n          let cssDim = dim / uPlot.pxRatio;\n          let maxTicks = Math.abs(Math.floor(cssDim / xSpacing));\n\n          skipMod = dataLen < maxTicks ? 0 : Math.ceil(dataLen / maxTicks);\n\n          let splits2 = splits.map((v, i) => {\n            let shouldSkip = skipMod !== 0 && (xSpacing > 0 ? i : lastIdx - i) % skipMod > 0;\n            return shouldSkip ? null : v;\n          });\n\n          return _dir === 1 ? splits2 : splits2.reverse();\n        };\n\n  // the splits passed into here are data[0] values looked up by the indices returned from splits()\n  const xValues: Axis.Values = (u, splits, axisIdx, foundSpace, foundIncr) => {\n    if (opts.xTimeAuto) {\n      let format = intervals.year;\n\n      if (foundIncr < timeUnitSize.second) {\n        format = intervals.millisecond;\n      } else if (foundIncr < timeUnitSize.minute) {\n        format = intervals.second;\n      } else if (foundIncr < timeUnitSize.hour) {\n        format = intervals.minute;\n      } else if (foundIncr < timeUnitSize.day) {\n        format = intervals.hour;\n      } else if (foundIncr < timeUnitSize.month) {\n        format = intervals.day;\n      } else if (foundIncr < timeUnitSize.year) {\n        format = intervals.month;\n      } else {\n        format = intervals.year;\n      }\n\n      return splits.map((v) => (v == null ? '' : dateTimeFormat(v, { format, timeZone })));\n    }\n\n    return splits.map((v) => (isXHorizontal ? formatShortValue(0, v) : formatValue(0, v)));\n  };\n\n  // this expands the distr: 2 scale so that the indicies of each data[0] land at the proper justified positions\n  const xRange: Scale.Range = (u, min, max) => {\n    min = 0;\n    max = Math.max(1, u.data[0].length - 1);\n\n    let pctOffset = 0;\n\n    // how far in is the first tick in % of full dimension\n    distribute(u.data[0].length, groupWidth, groupDistr, 0, (di, lftPct, widPct) => {\n      pctOffset = lftPct + widPct / 2;\n    });\n\n    // expand scale range by equal amounts on both ends\n    let rn = max - min;\n\n    if (pctOffset === 0.5) {\n      min -= rn;\n    } else {\n      let upScale = 1 / (1 - pctOffset * 2);\n      let offset = (upScale * rn - rn) / 2;\n\n      min -= offset;\n      max += offset;\n    }\n\n    return [min, max];\n  };\n\n  let distrTwo = (groupCount: number, barCount: number) => {\n    let out = Array.from({ length: barCount }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0),\n    }));\n\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct + groupDimPct * barOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct * barDimPct;\n      });\n    });\n\n    return out;\n  };\n\n  let distrOne = (groupCount: number, barCount: number) => {\n    let out = Array.from({ length: barCount }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0),\n    }));\n\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct;\n      });\n    });\n\n    return out;\n  };\n\n  const LABEL_OFFSET_FACTOR = isXHorizontal ? LABEL_OFFSET_FACTOR_VT : LABEL_OFFSET_FACTOR_HZ;\n  const LABEL_OFFSET_MAX = isXHorizontal ? LABEL_OFFSET_MAX_VT : LABEL_OFFSET_MAX_HZ;\n\n  let barsPctLayout: Array<null | { offs: number[]; size: number[] }> = [];\n  let barsColors: Array<null | { fill: Array<string | null>; stroke: Array<string | null> }> = [];\n  let scaleFactor = 1;\n  let labels: ValueLabelTable;\n  let fontSize = opts.text?.valueSize ?? VALUE_MAX_FONT_SIZE;\n  let labelOffset = LABEL_OFFSET_MAX;\n\n  // minimum available space for labels between bar end and plotting area bound (in canvas pixels)\n  let vSpace = Infinity;\n  let hSpace = Infinity;\n\n  let useMappedColors = getColor != null;\n\n  let mappedColorDisp = useMappedColors\n    ? {\n        fill: {\n          unit: 3,\n          values: (u: uPlot, seriesIdx: number) => barsColors[seriesIdx]!.fill,\n        },\n        stroke: {\n          unit: 3,\n          values: (u: uPlot, seriesIdx: number) => barsColors[seriesIdx]!.stroke,\n        },\n      }\n    : {};\n\n  let barsBuilder = uPlot.paths.bars!({\n    radius: pctStacked\n      ? 0\n      : !isStacked\n        ? barRadius\n        : (u: uPlot, seriesIdx: number) => {\n            let isTopmostSeries = seriesIdx === u.data.length - 1;\n            return isTopmostSeries ? [barRadius, 0] : [0, 0];\n          },\n    disp: {\n      x0: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx]!.offs,\n      },\n      size: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx]!.size,\n      },\n      ...mappedColorDisp,\n    },\n    // collect rendered bar geometry\n    each: (u, seriesIdx, dataIdx, lft, top, wid, hgt) => {\n      // we get back raw canvas coords (included axes & padding)\n      // translate to the plotting area origin\n      lft -= u.bbox.left;\n      top -= u.bbox.top;\n\n      let val = u.data[seriesIdx][dataIdx]!;\n      // accum min space abvailable for labels\n      if (isXHorizontal) {\n        vSpace = Math.min(vSpace, val < 0 ? u.bbox.height - (top + hgt) : top);\n        hSpace = wid;\n      } else {\n        vSpace = hgt;\n        hSpace = Math.min(hSpace, val < 0 ? lft : u.bbox.width - (lft + wid));\n      }\n\n      let barRect = { x: lft, y: top, w: wid, h: hgt, sidx: seriesIdx, didx: dataIdx };\n\n      if (!isStacked && opts.fullHighlight) {\n        if (opts.xOri === ScaleOrientation.Horizontal) {\n          barRect.y = 0;\n          barRect.h = u.bbox.height;\n        } else {\n          barRect.x = 0;\n          barRect.w = u.bbox.width;\n        }\n      }\n\n      qt.add(barRect);\n\n      if (showValue !== VisibilityMode.Never) {\n        const raw = rawValue(seriesIdx, dataIdx)!;\n        let divider = 1;\n\n        if (pctStacked && alignedTotals![seriesIdx][dataIdx]!) {\n          divider = alignedTotals![seriesIdx][dataIdx]!;\n        }\n\n        const v = divider === 0 ? 0 : raw / divider;\n        // Format Values and calculate label offsets\n        const text = formatValue(seriesIdx, v);\n        labelOffset = Math.min(labelOffset, Math.round(LABEL_OFFSET_FACTOR * (isXHorizontal ? wid : hgt)));\n\n        if (labels[dataIdx] === undefined) {\n          labels[dataIdx] = {};\n        }\n        labels[dataIdx][seriesIdx] = { text: text, value: rawValue(seriesIdx, dataIdx), hidden: false };\n\n        // Calculate font size when it's set to be automatic\n        if (hasAutoValueSize) {\n          const { fontSize: calculatedSize, textMetrics } = calculateFontSizeWithMetrics(\n            labels[dataIdx][seriesIdx].text,\n            hSpace * (isXHorizontal ? BAR_FONT_SIZE_RATIO : 1) - (isXHorizontal ? 0 : labelOffset),\n            vSpace * (isXHorizontal ? 1 : BAR_FONT_SIZE_RATIO) - (isXHorizontal ? labelOffset : 0),\n            1\n          );\n\n          // Save text metrics\n          labels[dataIdx][seriesIdx].textMetrics = textMetrics;\n\n          // Retrieve the new font size and use it\n          let autoFontSize = Math.round(Math.min(fontSize, VALUE_MAX_FONT_SIZE, calculatedSize));\n\n          // Calculate the scaling factor for bouding boxes\n          // Take into account the fact that calculateFontSize\n          // uses 14px measurement so we need to adjust the scale factor\n          scaleFactor = (autoFontSize / fontSize) * (autoFontSize / 14);\n\n          // Update the end font-size\n          fontSize = autoFontSize;\n        } else {\n          labels[dataIdx][seriesIdx].textMetrics = measureText(labels[dataIdx][seriesIdx].text, fontSize);\n        }\n\n        let middleShift = isXHorizontal ? 0 : -Math.round(MIDDLE_BASELINE_SHIFT * fontSize);\n        let value = rawValue(seriesIdx, dataIdx);\n\n        if (opts.negY?.[seriesIdx] && value != null) {\n          value *= -1;\n        }\n\n        if (value != null) {\n          // Calculate final co-ordinates for text position\n          const x =\n            u.bbox.left + (isXHorizontal ? lft + wid / 2 : value < 0 ? lft - labelOffset : lft + wid + labelOffset);\n          let y =\n            u.bbox.top +\n            (isXHorizontal ? (value < 0 ? top + hgt + labelOffset : top - labelOffset) : top + hgt / 2 - middleShift);\n\n          // Retrieve textMetrics with necessary default values\n          // These _shouldn't_ be undefined at this point\n          // but they _could_ be.\n          const {\n            textMetrics = {\n              width: 1,\n              actualBoundingBoxAscent: 1,\n              actualBoundingBoxDescent: 1,\n            },\n          } = labels[dataIdx][seriesIdx];\n\n          // Adjust bounding boxes based on text scale\n          // factor and orientation (which changes the baseline)\n          let xAdjust = 0,\n            yAdjust = 0;\n\n          if (isXHorizontal) {\n            // Adjust for baseline which is \"top\" in this case\n            xAdjust = (textMetrics.width * scaleFactor) / 2;\n\n            // yAdjust only matters when the value isn't negative\n            yAdjust =\n              value > 0\n                ? (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor\n                : 0;\n          } else {\n            // Adjust from the baseline which is \"middle\" in this case\n            yAdjust = ((textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor) / 2;\n\n            // Adjust for baseline being \"right\" in the x direction\n            xAdjust = value < 0 ? textMetrics.width * scaleFactor : 0;\n          }\n\n          // Force label bounding box y position to not be negative\n          if (y - yAdjust < 0) {\n            y = yAdjust;\n          }\n\n          // Construct final bounding box for the label text\n          labels[dataIdx][seriesIdx].x = x;\n          labels[dataIdx][seriesIdx].y = y;\n          labels[dataIdx][seriesIdx].bbox = {\n            x: x - xAdjust,\n            y: y - yAdjust,\n            w: textMetrics.width * scaleFactor,\n            h: (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor,\n          };\n        }\n      }\n    },\n  });\n\n  const init = (u: uPlot) => {\n    u.root.querySelectorAll<HTMLDivElement>('.u-cursor-pt').forEach((el) => {\n      el.style.borderRadius = '0';\n\n      if (opts.fullHighlight) {\n        el.style.zIndex = '-1';\n      }\n    });\n  };\n\n  const cursor: uPlot.Cursor = {\n    x: false,\n    y: false,\n    drag: {\n      x: false,\n      y: false,\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 0) {\n        hovered.fill(null);\n        hRect = null;\n\n        let cx = u.cursor.left! * uPlot.pxRatio;\n        let cy = u.cursor.top! * uPlot.pxRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = hovered[0] = o;\n            hovered[hRect.sidx] = hRect;\n\n            hoverMulti &&\n              findRects(qt, undefined, hRect.didx).forEach((r) => {\n                hovered[r.sidx] = r;\n              });\n          }\n        });\n      }\n\n      return hovered[seriesIdx]?.didx;\n    },\n    points: {\n      fill: 'rgba(255,255,255,0.4)',\n      bbox: (u, seriesIdx) => {\n        let hRect2 = hovered[seriesIdx];\n        let isHovered = hRect2 != null;\n\n        return {\n          left: isHovered ? hRect2!.x / uPlot.pxRatio : -10,\n          top: isHovered ? hRect2!.y / uPlot.pxRatio : -10,\n          width: isHovered ? hRect2!.w / uPlot.pxRatio : 0,\n          height: isHovered ? hRect2!.h / uPlot.pxRatio : 0,\n        };\n      },\n    },\n    focus: {\n      prox: 1e3,\n      dist: (u, seriesIdx) => (hRect?.sidx === seriesIdx ? 0 : Infinity),\n    },\n  };\n\n  // Build bars\n  const drawClear = (u: uPlot) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n    qt.clear();\n\n    // clear the path cache to force drawBars() to rebuild new quadtree\n    u.series.forEach((s) => {\n      // @ts-ignore\n      s._paths = null;\n    });\n\n    if (isStacked) {\n      barsPctLayout = [null, ...distrOne(u.data[0].length, u.data.length - 1)];\n    } else {\n      barsPctLayout = [null, ...distrTwo(u.data[0].length, u.data.length - 1)];\n    }\n\n    if (useMappedColors) {\n      barsColors = [null];\n\n      // map per-bar colors\n      for (let i = 1; i < u.data.length; i++) {\n        let colors = (u.data[i] as Array<number | null>).map((value, valueIdx) => {\n          if (value != null) {\n            return getColor!(i, valueIdx, value);\n          }\n\n          return null;\n        });\n\n        barsColors.push({\n          fill:\n            fillOpacity < 1 ? colors.map((c) => (c != null ? colorManipulator.alpha(c, fillOpacity) : null)) : colors,\n          stroke: colors,\n        });\n      }\n    }\n\n    labels = {};\n    fontSize = opts.text?.valueSize ?? VALUE_MAX_FONT_SIZE;\n    labelOffset = LABEL_OFFSET_MAX;\n    vSpace = hSpace = Infinity;\n  };\n\n  // uPlot hook to draw the labels on the bar chart.\n  const draw = (u: uPlot) => {\n    if (showValue === VisibilityMode.Never || fontSize < VALUE_MIN_FONT_SIZE) {\n      return;\n    }\n\n    u.ctx.save();\n    u.ctx.fillStyle = theme.colors.text.primary;\n    u.ctx.font = `${fontSize}px ${theme.typography.fontFamily}`;\n\n    let curAlign: CanvasTextAlign | undefined = undefined,\n      curBaseline: CanvasTextBaseline | undefined = undefined;\n\n    for (const didx in labels) {\n      // exclude first label from overlap testing\n      let first = true;\n\n      for (const sidx in labels[didx]) {\n        const label = labels[didx][sidx];\n        const { text, x = 0, y = 0 } = label;\n        let { value } = label;\n\n        if (opts.negY?.[sidx] && value != null) {\n          value *= -1;\n        }\n\n        let align: CanvasTextAlign = isXHorizontal ? 'center' : value !== null && value < 0 ? 'right' : 'left';\n        let baseline: CanvasTextBaseline = isXHorizontal\n          ? value !== null && value < 0\n            ? 'top'\n            : 'alphabetic'\n          : 'middle';\n\n        if (align !== curAlign) {\n          u.ctx.textAlign = curAlign = align;\n        }\n\n        if (baseline !== curBaseline) {\n          u.ctx.textBaseline = curBaseline = baseline;\n        }\n\n        if (showValue === VisibilityMode.Always) {\n          u.ctx.fillText(text, x, y);\n        } else if (showValue === VisibilityMode.Auto) {\n          let { bbox } = label;\n\n          let intersectsLabel = false;\n\n          if (bbox == null) {\n            intersectsLabel = true;\n            label.hidden = true;\n          } else if (!first) {\n            // Test for any collisions\n            for (const subsidx in labels[didx]) {\n              if (subsidx === sidx) {\n                continue;\n              }\n\n              const label2 = labels[didx][subsidx];\n              const { bbox: bbox2, hidden } = label2;\n\n              if (!hidden && bbox2 && intersects(bbox, bbox2)) {\n                intersectsLabel = true;\n                label.hidden = true;\n                break;\n              }\n            }\n          }\n\n          first = false;\n\n          !intersectsLabel && u.ctx.fillText(text, x, y);\n        }\n      }\n    }\n\n    u.ctx.restore();\n  };\n\n  let alignedTotals: AlignedData | null = null;\n\n  function prepData(frames: DataFrame[], stackingGroups: StackingGroup[]) {\n    alignedTotals = null;\n    return preparePlotData2(frames[0], stackingGroups, ({ totals }) => {\n      alignedTotals = totals;\n    });\n  }\n\n  return {\n    cursor,\n    // scale & axis opts\n    xRange,\n    xValues,\n    xSplits,\n    hFilter,\n\n    barsBuilder,\n\n    // hooks\n    init,\n    drawClear,\n    draw,\n    prepData,\n  };\n}\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as common from '@grafana/schema';\n\nexport interface Options extends common.OptionsWithLegend, common.OptionsWithTooltip, common.OptionsWithTextFormatting {\n  /**\n   * Controls the radius of each bar.\n   */\n  barRadius?: number;\n  /**\n   * Controls the width of bars. 1 = Max width, 0 = Min width.\n   */\n  barWidth: number;\n  /**\n   * Use the color value for a sibling field to color each bar value.\n   */\n  colorByField?: string;\n  /**\n   * Enables mode which highlights the entire bar area and shows tooltip when cursor\n   * hovers over highlighted area\n   */\n  fullHighlight: boolean;\n  /**\n   * Controls the width of groups. 1 = max with, 0 = min width.\n   */\n  groupWidth: number;\n  /**\n   * Controls the orientation of the bar chart, either vertical or horizontal.\n   */\n  orientation: common.VizOrientation;\n  /**\n   * This controls whether values are shown on top or to the left of bars.\n   */\n  showValue: common.VisibilityMode;\n  /**\n   * Controls whether bars are stacked or not, either normally or in percent mode.\n   */\n  stacking: common.StackingMode;\n  /**\n   * Manually select which field from the dataset to represent the x field.\n   */\n  xField?: string;\n  /**\n   * Sets the max length that a label can have before it is truncated.\n   */\n  xTickLabelMaxLength: number;\n  /**\n   * Controls the rotation of the x axis labels.\n   */\n  xTickLabelRotation: number;\n  /**\n   * Controls the spacing between x axis labels.\n   * negative values indicate backwards skipping behavior\n   */\n  xTickLabelSpacing?: number;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  barRadius: 0,\n  barWidth: 0.97,\n  fullHighlight: false,\n  groupWidth: 0.7,\n  orientation: common.VizOrientation.Auto,\n  showValue: common.VisibilityMode.Auto,\n  stacking: common.StackingMode.None,\n  xTickLabelRotation: 0,\n  xTickLabelSpacing: 0,\n};\n\nexport interface FieldConfig extends common.AxisConfig, common.HideableFieldConfig {\n  /**\n   * Controls the fill opacity of the bars.\n   */\n  fillOpacity?: number;\n  /**\n   * Set the mode of the gradient fill. Fill gradient is based on the line color. To change the color, use the standard color scheme field option.\n   * Gradient appearance is influenced by the Fill opacity setting.\n   */\n  gradientMode?: common.GraphGradientMode;\n  /**\n   * Controls line width of the bars.\n   */\n  lineWidth?: number;\n  /**\n   * Threshold rendering\n   */\n  thresholdsStyle?: common.GraphThresholdsStyleConfig;\n}\n\nexport const defaultFieldConfig: Partial<FieldConfig> = {\n  fillOpacity: 80,\n  gradientMode: common.GraphGradientMode.None,\n  lineWidth: 1,\n};\n","import uPlot, { Padding } from 'uplot';\n\nimport {\n  DataFrame,\n  Field,\n  FieldConfigSource,\n  FieldType,\n  GrafanaTheme2,\n  cacheFieldDisplayNames,\n  formattedValueToString,\n  getDisplayProcessor,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  outerJoinDataFrames,\n} from '@grafana/data';\nimport { decoupleHideFromState } from '@grafana/data/internal';\nimport {\n  AxisColorMode,\n  AxisPlacement,\n  FieldColorModeId,\n  GraphThresholdsStyleMode,\n  GraphTransform,\n  ScaleDistribution,\n  TimeZone,\n  TooltipDisplayMode,\n  VizOrientation,\n} from '@grafana/schema';\nimport {\n  FIXED_UNIT,\n  ScaleDirection,\n  ScaleOrientation,\n  StackingMode,\n  UPlotConfigBuilder,\n  measureText,\n} from '@grafana/ui';\nimport { AxisProps, UPLOT_AXIS_FONT_SIZE, getStackingGroups } from '@grafana/ui/internal';\n\nimport { setClassicPaletteIdxs } from '../timeseries/utils';\n\nimport { BarsOptions, getConfig } from './bars';\nimport { FieldConfig, Options, defaultFieldConfig } from './panelcfg.gen';\n// import { isLegendOrdered } from './utils';\n\ninterface BarSeries {\n  series: DataFrame[];\n  _rest: Field[];\n  color?: Field | null;\n  warn?: string | null;\n}\n\nexport function prepSeries(\n  frames: DataFrame[],\n  fieldConfig: FieldConfigSource,\n  stacking: StackingMode,\n  theme: GrafanaTheme2,\n  xFieldName?: string,\n  colorFieldName?: string\n): BarSeries {\n  if (frames.length === 0 || frames.every((fr) => fr.length === 0)) {\n    return { series: [], _rest: [], warn: 'No data in response' };\n  }\n\n  cacheFieldDisplayNames(frames);\n  decoupleHideFromState(frames, fieldConfig);\n\n  let frame: DataFrame | undefined = { ...frames[0] };\n\n  // auto-sort and/or join on first time field (if any)\n  // TODO: should this always join on the xField (if supplied?)\n  const timeFieldIdx = frame.fields.findIndex((f) => f.type === FieldType.time);\n\n  if (timeFieldIdx >= 0 && frames.length > 1) {\n    frame = outerJoinDataFrames({ frames, keepDisplayNames: true }) ?? frame;\n  }\n\n  const xField =\n    // TODO: use matcher\n    frame.fields.find((field) => field.state?.displayName === xFieldName || field.name === xFieldName) ??\n    frame.fields.find((field) => field.type === FieldType.string) ??\n    frame.fields[timeFieldIdx];\n\n  if (xField != null) {\n    const fields: Field[] = [xField];\n    const _rest: Field[] = [];\n\n    const colorField =\n      colorFieldName == null\n        ? undefined\n        : frame.fields.find(\n            // TODO: use matcher\n            (field) => field.state?.displayName === colorFieldName || field.name === colorFieldName\n          );\n\n    frame.fields.forEach((field) => {\n      if (field !== xField) {\n        if (field.type === FieldType.number && !field.config.custom?.hideFrom?.viz) {\n          const field2 = {\n            ...field,\n            values: field.values.map((v) => (Number.isFinite(v) ? v : null)),\n            // TODO: stacking should be moved from panel opts to fieldConfig (like TimeSeries) so we dont have to do this\n            config: {\n              ...field.config,\n              custom: {\n                ...field.config.custom,\n                stacking: {\n                  group: '_',\n                  mode: stacking,\n                },\n              },\n            },\n          };\n\n          fields.push(field2);\n        } else {\n          _rest.push(field);\n        }\n      }\n    });\n\n    let warn: string | null = null;\n\n    if (fields.length === 1) {\n      warn = 'No numeric fields found';\n    }\n\n    frame.fields = fields;\n\n    const series = [frame];\n\n    setClassicPaletteIdxs(series, theme, 0);\n\n    return {\n      series,\n      _rest,\n      color: colorField,\n      warn,\n    };\n  }\n\n  return {\n    series: [],\n    _rest: [],\n    color: null,\n    warn: 'Bar charts requires a string or time field',\n  };\n}\n\nexport interface PrepConfigOpts {\n  series: DataFrame[]; // series with hideFrom.viz: false\n  totalSeries: number; // total series count (including hidden)\n  color?: Field | null;\n  orientation: VizOrientation;\n  options: Options;\n  timeZone: TimeZone;\n  theme: GrafanaTheme2;\n}\n\nexport const prepConfig = ({ series, totalSeries, color, orientation, options, timeZone, theme }: PrepConfigOpts) => {\n  let {\n    showValue,\n    groupWidth,\n    barWidth,\n    barRadius = 0,\n    stacking,\n    text,\n    tooltip,\n    xTickLabelRotation,\n    xTickLabelMaxLength,\n    xTickLabelSpacing = 0,\n    legend,\n    fullHighlight,\n  } = options;\n  // this and color is kept up to date by returned prepData()\n  let frame = series[0];\n\n  const builder = new UPlotConfigBuilder();\n\n  const formatters = frame.fields.map((f, i) => {\n    if (stacking === StackingMode.Percent) {\n      return getDisplayProcessor({\n        field: {\n          ...f,\n          config: {\n            ...f.config,\n            unit: 'percentunit',\n          },\n        },\n        theme,\n      });\n    }\n\n    return f.display!;\n  });\n\n  const formatValue = (seriesIdx: number, value: unknown) => {\n    return formattedValueToString(formatters[seriesIdx](value));\n  };\n\n  const formatShortValue = (seriesIdx: number, value: unknown) => {\n    return shortenValue(formatValue(seriesIdx, value), xTickLabelMaxLength);\n  };\n\n  // bar orientation -> x scale orientation & direction\n  const vizOrientation = getScaleOrientation(orientation);\n\n  // Use bar width when only one field\n  if (frame.fields.length === 2 && stacking === StackingMode.None) {\n    if (totalSeries === 1) {\n      groupWidth = barWidth;\n    }\n\n    barWidth = 1;\n  }\n\n  const rawValue = (seriesIdx: number, valueIdx: number) => {\n    return frame.fields[seriesIdx].values[valueIdx];\n  };\n\n  // Color by value\n  let getColor: ((seriesIdx: number, valueIdx: number) => string) | undefined = undefined;\n\n  let fillOpacity = 1;\n\n  if (color != null) {\n    const disp = color.display!;\n    fillOpacity = (color.config.custom.fillOpacity ?? 100) / 100;\n    // gradientMode? ignore?\n    getColor = (seriesIdx: number, valueIdx: number) => disp(color!.values[valueIdx]).color!;\n  } else {\n    const hasPerBarColor = frame.fields.some((f) => {\n      const fromThresholds = f.config.color?.mode === FieldColorModeId.Thresholds;\n\n      return (\n        fromThresholds ||\n        f.config.mappings?.some((m) => {\n          // ValueToText mappings have a different format, where all of them are grouped into an object keyed by value\n          if (m.type === 'value') {\n            // === MappingType.ValueToText\n            return Object.values(m.options).some((result) => result.color != null);\n          }\n          return m.options.result.color != null;\n        })\n      );\n    });\n\n    if (hasPerBarColor) {\n      // use opacity from first numeric field\n      let opacityField = frame.fields.find((f) => f.type === FieldType.number)!;\n\n      fillOpacity = (opacityField?.config?.custom?.fillOpacity ?? 100) / 100;\n\n      getColor = (seriesIdx: number, valueIdx: number) => {\n        let field = frame.fields[seriesIdx];\n        return field.display!(field.values[valueIdx]).color!;\n      };\n    }\n  }\n\n  const opts: BarsOptions = {\n    xOri: vizOrientation.xOri,\n    xDir: vizOrientation.xDir,\n    groupWidth,\n    barWidth,\n    barRadius,\n    stacking,\n    rawValue,\n    getColor,\n    fillOpacity,\n    formatValue,\n    formatShortValue,\n    timeZone,\n    text,\n    showValue,\n    legend,\n    xSpacing: xTickLabelSpacing,\n    xTimeAuto: frame.fields[0]?.type === FieldType.time && !frame.fields[0].config.unit?.startsWith('time:'),\n    negY: frame.fields.map((f) => f.config.custom?.transform === GraphTransform.NegativeY),\n    fullHighlight,\n    hoverMulti: tooltip.mode === TooltipDisplayMode.Multi,\n  };\n\n  const config = getConfig(opts, theme);\n\n  builder.setCursor(config.cursor);\n\n  builder.addHook('init', config.init);\n  builder.addHook('drawClear', config.drawClear);\n  builder.addHook('draw', config.draw);\n\n  if (xTickLabelRotation !== 0) {\n    // these are the amount of space we already have available between plot edge and first label\n    // TODO: removing these hardcoded value requires reading back uplot instance props\n    let lftSpace = 50;\n    let btmSpace = vizOrientation.xOri === ScaleOrientation.Horizontal ? 14 : 5;\n\n    builder.setPadding(getRotationPadding(frame, xTickLabelRotation, xTickLabelMaxLength, lftSpace, btmSpace));\n  }\n\n  builder.setPrepData(config.prepData);\n\n  builder.addScale({\n    scaleKey: 'x',\n    isTime: false,\n    range: config.xRange,\n    distribution: ScaleDistribution.Ordinal,\n    orientation: vizOrientation.xOri,\n    direction: vizOrientation.xDir,\n  });\n\n  const xFieldAxisPlacement =\n    frame.fields[0]?.config.custom?.axisPlacement !== AxisPlacement.Hidden\n      ? vizOrientation.xOri === ScaleOrientation.Horizontal\n        ? AxisPlacement.Bottom\n        : AxisPlacement.Left\n      : AxisPlacement.Hidden;\n  const xFieldAxisShow = frame.fields[0]?.config.custom?.axisPlacement !== AxisPlacement.Hidden;\n\n  builder.addAxis({\n    scaleKey: 'x',\n    isTime: false,\n    placement: xFieldAxisPlacement,\n    label: frame.fields[0]?.config.custom?.axisLabel,\n    splits: config.xSplits,\n    filter: vizOrientation.xOri === 0 ? config.hFilter : undefined,\n    values: config.xValues,\n    timeZone,\n    grid: { show: false },\n    ticks: { show: false },\n    gap: 15,\n    tickLabelRotation: vizOrientation.xOri === 0 ? xTickLabelRotation * -1 : 0,\n    theme,\n    show: xFieldAxisShow,\n  });\n\n  // let seriesIndex = 0;\n  // const legendOrdered = isLegendOrdered(legend);\n\n  // iterate the y values\n  for (let i = 1; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    // seriesIndex++;\n\n    const customConfig: FieldConfig = { ...defaultFieldConfig, ...field.config.custom };\n\n    const scaleKey = field.config.unit || FIXED_UNIT;\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    // make barcharts start at 0 unless explicitly overridden\n    let softMin = customConfig.axisSoftMin;\n    let softMax = customConfig.axisSoftMax;\n\n    if (softMin == null && field.config.min == null) {\n      softMin = 0;\n    }\n\n    if (softMax == null && field.config.max == null) {\n      softMax = 0;\n    }\n\n    // Render thresholds in graph\n    if (customConfig.thresholdsStyle && field.config.thresholds) {\n      const thresholdDisplay = customConfig.thresholdsStyle.mode ?? GraphThresholdsStyleMode.Off;\n      if (thresholdDisplay !== GraphThresholdsStyleMode.Off) {\n        builder.addThresholds({\n          config: customConfig.thresholdsStyle,\n          thresholds: field.config.thresholds,\n          scaleKey,\n          theme,\n          hardMin: field.config.min,\n          hardMax: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n        });\n      }\n    }\n\n    builder.addSeries({\n      scaleKey,\n      pxAlign: true,\n      lineWidth: customConfig.lineWidth,\n      lineColor: seriesColor,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      colorMode,\n      pathBuilder: config.barsBuilder,\n      show: !customConfig.hideFrom?.viz,\n      gradientMode: customConfig.gradientMode,\n      thresholds: field.config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      // PlotLegend currently gets unfiltered DataFrame[], so index must be into that field array, not the prepped frame's which we're iterating here\n      // dataFrameFieldIndex: {\n      //   fieldIndex: legendOrdered\n      //     ? i\n      //     : allFrames[0].fields.findIndex(\n      //         (f) => f.type === FieldType.number && f.state?.seriesIndex === seriesIndex - 1\n      //       ),\n      //   frameIndex: 0,\n      // },\n    });\n\n    // The builder will manage unique scaleKeys and combine where appropriate\n    builder.addScale({\n      scaleKey,\n      min: field.config.min,\n      max: field.config.max,\n      softMin,\n      softMax,\n      centeredZero: customConfig.axisCenteredZero,\n      orientation: vizOrientation.yOri,\n      direction: vizOrientation.yDir,\n      distribution: customConfig.scaleDistribution?.type,\n      log: customConfig.scaleDistribution?.log,\n      decimals: field.config.decimals,\n    });\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      let placement = customConfig.axisPlacement;\n      if (!placement || placement === AxisPlacement.Auto) {\n        placement = AxisPlacement.Left;\n      }\n      if (vizOrientation.xOri === 1) {\n        if (placement === AxisPlacement.Left) {\n          placement = AxisPlacement.Bottom;\n        }\n        if (placement === AxisPlacement.Right) {\n          placement = AxisPlacement.Top;\n        }\n      }\n\n      let axisOpts: AxisProps = {\n        scaleKey,\n        label: customConfig.axisLabel,\n        size: customConfig.axisWidth,\n        placement,\n        formatValue: (v, decimals) => formattedValueToString(field.display!(v, decimals)),\n        filter: vizOrientation.yOri === 0 ? config.hFilter : undefined,\n        tickLabelRotation: vizOrientation.xOri === 1 ? xTickLabelRotation * -1 : 0,\n        theme,\n        grid: { show: customConfig.axisGridShow },\n        decimals: field.config.decimals,\n      };\n\n      if (customConfig.axisBorderShow) {\n        axisOpts.border = {\n          show: true,\n        };\n      }\n\n      if (customConfig.axisColorMode === AxisColorMode.Series) {\n        axisOpts.color = seriesColor;\n      }\n\n      builder.addAxis(axisOpts);\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n\n  builder.setStackingGroups(stackingGroups);\n\n  return {\n    builder,\n    prepData: (_series: DataFrame[], _color?: Field | null) => {\n      series = _series;\n      frame = series[0];\n      color = _color;\n\n      return builder.prepData!(series);\n    },\n  };\n};\n\nfunction shortenValue(value: string, length: number) {\n  if (value.length > length) {\n    return value.substring(0, length).concat('...');\n  } else {\n    return value;\n  }\n}\n\nfunction getRotationPadding(\n  frame: DataFrame,\n  rotateLabel: number,\n  valueMaxLength: number,\n  lftSpace = 0,\n  btmSpace = 0\n): Padding {\n  const values = frame.fields[0].values;\n  const fontSize = UPLOT_AXIS_FONT_SIZE;\n  const displayProcessor = frame.fields[0].display;\n  const getProcessedValue = (i: number) => {\n    return displayProcessor ? displayProcessor(values[i]) : values[i];\n  };\n  let maxLength = 0;\n  for (let i = 0; i < values.length; i++) {\n    let size = measureText(shortenValue(formattedValueToString(getProcessedValue(i)), valueMaxLength), fontSize);\n    maxLength = size.width > maxLength ? size.width : maxLength;\n  }\n\n  // Add padding to the right if the labels are rotated in a way that makes the last label extend outside the graph.\n  const paddingRight =\n    rotateLabel > 0\n      ? Math.cos((rotateLabel * Math.PI) / 180) *\n        measureText(\n          shortenValue(formattedValueToString(getProcessedValue(values.length - 1)), valueMaxLength),\n          fontSize\n        ).width\n      : 0;\n\n  // Add padding to the left if the labels are rotated in a way that makes the first label extend outside the graph.\n  const paddingLeft =\n    rotateLabel < 0\n      ? Math.cos((rotateLabel * -1 * Math.PI) / 180) *\n        measureText(shortenValue(formattedValueToString(getProcessedValue(0)), valueMaxLength), fontSize).width\n      : 0;\n\n  // Add padding to the bottom to avoid clipping the rotated labels.\n  const paddingBottom =\n    Math.sin(((rotateLabel >= 0 ? rotateLabel : rotateLabel * -1) * Math.PI) / 180) * maxLength - btmSpace;\n\n  return [\n    Math.round(UPLOT_AXIS_FONT_SIZE * uPlot.pxRatio),\n    paddingRight,\n    paddingBottom,\n    Math.max(0, paddingLeft - lftSpace),\n  ];\n}\n\nfunction getScaleOrientation(orientation: VizOrientation) {\n  if (orientation === VizOrientation.Vertical) {\n    return {\n      xOri: ScaleOrientation.Horizontal,\n      xDir: ScaleDirection.Right,\n      yOri: ScaleOrientation.Vertical,\n      yDir: ScaleDirection.Up,\n    };\n  }\n\n  return {\n    xOri: ScaleOrientation.Vertical,\n    xDir: ScaleDirection.Down,\n    yOri: ScaleOrientation.Horizontal,\n    yDir: ScaleDirection.Right,\n  };\n}\n","import { useMemo } from 'react';\n\nimport { PanelProps, VizOrientation } from '@grafana/data';\nimport { PanelDataErrorView } from '@grafana/runtime';\nimport {\n  TooltipDisplayMode,\n  TooltipPlugin2,\n  UPLOT_AXIS_FONT_SIZE,\n  UPlotChart,\n  VizLayout,\n  measureText,\n  // usePanelContext,\n  useTheme2,\n} from '@grafana/ui';\nimport { TooltipHoverMode } from '@grafana/ui/internal';\n\nimport { TimeSeriesTooltip } from '../timeseries/TimeSeriesTooltip';\n\nimport { BarChartLegend, hasVisibleLegendSeries } from './BarChartLegend';\nimport { Options } from './panelcfg.gen';\nimport { prepConfig, prepSeries } from './utils';\n\nconst charWidth = measureText('M', UPLOT_AXIS_FONT_SIZE).width;\nconst toRads = Math.PI / 180;\n\nexport const BarChartPanel = (props: PanelProps<Options>) => {\n  const { data, options, fieldConfig, width, height, timeZone, id, replaceVariables } = props;\n\n  // will need this if joining on time to re-create data links\n  // const { dataLinkPostProcessor } = usePanelContext();\n\n  const theme = useTheme2();\n\n  const {\n    barWidth,\n    barRadius = 0,\n    showValue,\n    groupWidth,\n    stacking,\n    legend,\n    tooltip,\n    text,\n    xTickLabelRotation,\n    xTickLabelSpacing,\n    fullHighlight,\n    xField,\n    colorByField,\n  } = options;\n\n  // size-dependent, calculated opts that should cause viz re-config\n  let { orientation, xTickLabelMaxLength = 0 } = options;\n\n  orientation =\n    orientation === VizOrientation.Auto\n      ? width < height\n        ? VizOrientation.Horizontal\n        : VizOrientation.Vertical\n      : orientation;\n\n  // TODO: this can be moved into axis calc internally, no need to re-config based on this\n  // should be based on vizHeight, not full height?\n  xTickLabelMaxLength =\n    xTickLabelRotation === 0\n      ? Infinity // should this calc using spacing between groups?\n      : xTickLabelMaxLength ||\n        // auto max length clamps to half viz height, subracts 3 chars for ... ellipsis\n        Math.floor(height / 2 / Math.sin(Math.abs(xTickLabelRotation * toRads)) / charWidth - 3);\n\n  // TODO: config data links\n  const info = useMemo(\n    () => prepSeries(data.series, fieldConfig, stacking, theme, xField, colorByField),\n    [data.series, fieldConfig, stacking, theme, xField, colorByField]\n  );\n\n  const vizSeries = useMemo(\n    () =>\n      info.series.map((frame) => ({\n        ...frame,\n        fields: frame.fields.filter((field, i) => i === 0 || !field.state?.hideFrom?.viz),\n      })),\n    [info.series]\n  );\n\n  const xGroupsCount = vizSeries[0]?.length ?? 0;\n  const seriesCount = vizSeries[0]?.fields.length ?? 0;\n  const totalSeries = Math.max(0, (info.series[0]?.fields.length ?? 0) - 1);\n\n  let { builder, prepData } = useMemo(\n    () => {\n      return xGroupsCount === 0\n        ? { builder: null, prepData: null }\n        : prepConfig({ series: vizSeries, totalSeries, color: info.color, orientation, options, timeZone, theme });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      orientation,\n      timeZone,\n      props.data.structureRev,\n\n      totalSeries,\n      seriesCount,\n      xGroupsCount,\n\n      barWidth,\n      barRadius,\n      showValue,\n      groupWidth,\n      stacking,\n      legend,\n      tooltip,\n      text?.valueSize, // cause text obj is re-created each time?\n      xTickLabelRotation,\n      xTickLabelSpacing,\n      fullHighlight,\n      xField,\n      colorByField,\n      xTickLabelMaxLength, // maybe not?\n      // props.fieldConfig, // usePrevious hideFrom on all fields?\n    ]\n  );\n\n  const plotData = useMemo(\n    () => (prepData == null ? [] : prepData(vizSeries, info.color)),\n    [prepData, vizSeries, info.color]\n  );\n\n  if (info.warn != null || builder == null) {\n    return (\n      <PanelDataErrorView\n        panelId={id}\n        fieldConfig={fieldConfig}\n        data={data}\n        message={info.warn ?? ''}\n        needsNumberField={true}\n      />\n    );\n  }\n\n  const legendComp =\n    legend.showLegend && hasVisibleLegendSeries(builder, info.series!) ? (\n      <BarChartLegend data={info.series!} colorField={info.color} {...legend} />\n    ) : null;\n\n  return (\n    <VizLayout\n      width={props.width}\n      height={props.height}\n      // legend={<BarChartLegend frame={info.series![0]} colorField={info.color} {...legend} />}\n      legend={legendComp}\n    >\n      {(vizWidth, vizHeight) => (\n        <UPlotChart config={builder!} data={plotData} width={vizWidth} height={vizHeight}>\n          {props.options.tooltip.mode !== TooltipDisplayMode.None && (\n            <TooltipPlugin2\n              config={builder}\n              maxWidth={options.tooltip.maxWidth}\n              hoverMode={\n                options.tooltip.mode === TooltipDisplayMode.Single ? TooltipHoverMode.xOne : TooltipHoverMode.xAll\n              }\n              getDataLinks={(seriesIdx, dataIdx) =>\n                vizSeries[0].fields[seriesIdx].getLinks?.({ valueRowIndex: dataIdx }) ?? []\n              }\n              render={(u, dataIdxs, seriesIdx, isPinned, dismiss, timeRange2, viaSync, dataLinks) => {\n                return (\n                  <TimeSeriesTooltip\n                    series={vizSeries[0]}\n                    _rest={info._rest}\n                    dataIdxs={dataIdxs}\n                    seriesIdx={seriesIdx}\n                    mode={options.tooltip.mode}\n                    sortOrder={options.tooltip.sort}\n                    isPinned={isPinned}\n                    maxHeight={options.tooltip.maxHeight}\n                    replaceVariables={replaceVariables}\n                    dataLinks={dataLinks}\n                    hideZeros={options.tooltip.hideZeros}\n                  />\n                );\n              }}\n            />\n          )}\n        </UPlotChart>\n      )}\n    </VizLayout>\n  );\n};\n","import { SelectableValue, StandardEditorProps } from '@grafana/data';\nimport { Checkbox, HorizontalGroup, RadioButtonGroup, Tooltip } from '@grafana/ui';\n\nconst GAPS_OPTIONS: Array<SelectableValue<number>> = [\n  {\n    label: 'None',\n    value: 0,\n    description: 'Show all tick marks',\n  },\n  {\n    label: 'Small',\n    value: 100,\n    description: 'Require 100px spacing',\n  },\n  {\n    label: 'Medium',\n    value: 200,\n    description: 'Require 200px spacing',\n  },\n  {\n    label: 'Large',\n    value: 300,\n    description: 'Require 300px spacing',\n  },\n];\n\nexport const TickSpacingEditor = (props: StandardEditorProps<number>) => {\n  let value = props.value ?? 0;\n  const isRTL = value < 0;\n  if (isRTL) {\n    value *= -1;\n  }\n  let gap = GAPS_OPTIONS[0];\n  for (const v of GAPS_OPTIONS) {\n    gap = v;\n    if (value <= gap.value!) {\n      break;\n    }\n  }\n\n  const onSpacingChange = (val: number) => {\n    props.onChange(val * (isRTL ? -1 : 1));\n  };\n\n  const onRTLChange = () => {\n    props.onChange(props.value * -1);\n  };\n\n  return (\n    <HorizontalGroup>\n      <RadioButtonGroup value={gap.value} options={GAPS_OPTIONS} onChange={onSpacingChange} />\n      {value !== 0 && (\n        <Tooltip content=\"Require space from the right side\" placement=\"top\">\n          <div>\n            <Checkbox value={isRTL} onChange={onRTLChange} label=\"RTL\" />\n          </div>\n        </Tooltip>\n      )}\n    </HorizontalGroup>\n  );\n};\n","import { FieldMatcherID, PanelTypeChangedHandler, ReducerID } from '@grafana/data';\nimport { AxisPlacement } from '@grafana/ui';\n\n/*\n * This is called when the panel changes from another panel\n */\nexport const changeToBarChartPanelMigrationHandler: PanelTypeChangedHandler = (panel, prevPluginId, prevOptions) => {\n  if (prevPluginId === 'graph') {\n    const graphOptions: GraphOptions = prevOptions.angular;\n\n    const fieldConfig = panel.fieldConfig ?? { defaults: {}, overrides: [] };\n\n    if (graphOptions.xaxis?.mode === 'series') {\n      const transformations = panel.transformations || [];\n      transformations.push(\n        {\n          id: 'reduce',\n          options: {\n            reducers: getReducer(graphOptions.xaxis?.values),\n          },\n        },\n        {\n          id: 'transpose',\n          options: {},\n        }\n      );\n\n      panel.transformations = transformations;\n\n      // temporary, until we have a bar chart with per bar labels\n      fieldConfig.overrides.push({\n        matcher: {\n          id: FieldMatcherID.byName,\n          options: 'Field',\n        },\n        properties: [\n          {\n            id: 'custom.axisPlacement',\n            value: AxisPlacement.Hidden,\n          },\n        ],\n      });\n\n      panel.fieldConfig = fieldConfig;\n      panel.options = {\n        ...panel.options,\n        groupWidth: 1,\n      };\n    }\n  }\n\n  return {};\n};\n\n// same as grafana-ui/src/components/SingleStatShared/SingleStatBaseOptions.ts\nconst getReducer = (reducers: string[] | undefined) => {\n  const transformReducers: string[] = [];\n\n  reducers?.forEach((reducer) => {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    if (!Object.values(ReducerID).includes(reducer as ReducerID)) {\n      if (reducer === 'current') {\n        transformReducers.push(ReducerID.lastNotNull);\n      } else if (reducer === 'total') {\n        transformReducers.push(ReducerID.sum);\n      } else if (reducer === 'avg') {\n        transformReducers.push(ReducerID.mean);\n      }\n    } else {\n      transformReducers.push(reducer);\n    }\n  });\n\n  return reducers ? transformReducers : [ReducerID.sum];\n};\n\ninterface GraphOptions {\n  xaxis: {\n    mode: 'series' | 'time' | 'histogram';\n    values?: string[];\n  };\n}\n","import { VisualizationSuggestionsBuilder, VizOrientation } from '@grafana/data';\nimport { LegendDisplayMode, StackingMode, VisibilityMode } from '@grafana/schema';\nimport { SuggestionName } from 'app/types/suggestions';\n\nimport { FieldConfig, Options } from './panelcfg.gen';\n\nexport class BarChartSuggestionsSupplier {\n  getListWithDefaults(builder: VisualizationSuggestionsBuilder) {\n    return builder.getListAppender<Options, FieldConfig>({\n      name: SuggestionName.BarChart,\n      pluginId: 'barchart',\n      options: {\n        showValue: VisibilityMode.Never,\n        legend: {\n          calcs: [],\n          displayMode: LegendDisplayMode.List,\n          showLegend: true,\n          placement: 'right',\n        },\n      },\n      fieldConfig: {\n        defaults: {\n          unit: 'short',\n          custom: {},\n        },\n        overrides: [],\n      },\n      cardOptions: {\n        previewModifier: (s) => {\n          s.options!.barWidth = 0.8;\n        },\n      },\n    });\n  }\n\n  getSuggestionsForData(builder: VisualizationSuggestionsBuilder) {\n    const list = this.getListWithDefaults(builder);\n    const { dataSummary } = builder;\n\n    if (dataSummary.frameCount !== 1) {\n      return;\n    }\n\n    if (!dataSummary.hasNumberField || !dataSummary.hasStringField) {\n      return;\n    }\n\n    // if you have this many rows barchart might not be a good fit\n    if (dataSummary.rowCountTotal > 50) {\n      return;\n    }\n\n    // Vertical bars\n    list.append({\n      name: SuggestionName.BarChart,\n    });\n\n    if (dataSummary.numberFieldCount > 1) {\n      list.append({\n        name: SuggestionName.BarChartStacked,\n        options: {\n          stacking: StackingMode.Normal,\n        },\n      });\n      list.append({\n        name: SuggestionName.BarChartStackedPercent,\n        options: {\n          stacking: StackingMode.Percent,\n        },\n      });\n    }\n\n    // horizontal bars\n    list.append({\n      name: SuggestionName.BarChartHorizontal,\n      options: {\n        orientation: VizOrientation.Horizontal,\n      },\n    });\n\n    if (dataSummary.numberFieldCount > 1) {\n      list.append({\n        name: SuggestionName.BarChartHorizontalStacked,\n        options: {\n          stacking: StackingMode.Normal,\n          orientation: VizOrientation.Horizontal,\n        },\n      });\n\n      list.append({\n        name: SuggestionName.BarChartHorizontalStackedPercent,\n        options: {\n          orientation: VizOrientation.Horizontal,\n          stacking: StackingMode.Percent,\n        },\n      });\n    }\n  }\n}\n","import {\n  DataFrame,\n  FieldColorModeId,\n  FieldConfigProperty,\n  FieldType,\n  identityOverrideProcessor,\n  PanelPlugin,\n  VizOrientation,\n} from '@grafana/data';\nimport { GraphTransform, GraphThresholdsStyleMode, StackingMode, VisibilityMode } from '@grafana/schema';\nimport { graphFieldOptions, commonOptionsBuilder } from '@grafana/ui';\nimport { optsWithHideZeros } from '@grafana/ui/internal';\n\nimport { ThresholdsStyleEditor } from '../timeseries/ThresholdsStyleEditor';\n\nimport { BarChartPanel } from './BarChartPanel';\nimport { TickSpacingEditor } from './TickSpacingEditor';\nimport { changeToBarChartPanelMigrationHandler } from './migrations';\nimport { FieldConfig, Options, defaultFieldConfig, defaultOptions } from './panelcfg.gen';\nimport { BarChartSuggestionsSupplier } from './suggestions';\n\nexport const plugin = new PanelPlugin<Options, FieldConfig>(BarChartPanel)\n  .setPanelChangeHandler(changeToBarChartPanelMigrationHandler)\n  .useFieldConfig({\n    standardOptions: {\n      [FieldConfigProperty.Color]: {\n        settings: {\n          byValueSupport: true,\n          preferThresholdsMode: false,\n        },\n        defaultValue: {\n          mode: FieldColorModeId.PaletteClassic,\n        },\n      },\n      [FieldConfigProperty.Links]: {\n        settings: {\n          showOneClick: true,\n        },\n      },\n      [FieldConfigProperty.Actions]: {\n        hideFromDefaults: false,\n      },\n    },\n    useCustomConfig: (builder) => {\n      const cfg = defaultFieldConfig;\n\n      builder\n        .addSliderInput({\n          path: 'lineWidth',\n          name: 'Line width',\n          defaultValue: cfg.lineWidth,\n          settings: {\n            min: 0,\n            max: 10,\n            step: 1,\n          },\n        })\n        .addSliderInput({\n          path: 'fillOpacity',\n          name: 'Fill opacity',\n          defaultValue: cfg.fillOpacity,\n          settings: {\n            min: 0,\n            max: 100,\n            step: 1,\n          },\n        })\n        .addRadio({\n          path: 'gradientMode',\n          name: 'Gradient mode',\n          defaultValue: graphFieldOptions.fillGradient[0].value,\n          settings: {\n            options: graphFieldOptions.fillGradient,\n          },\n        });\n\n      builder.addSelect({\n        category: ['Graph styles'],\n        name: 'Transform',\n        path: 'transform',\n        settings: {\n          options: [\n            {\n              label: 'Constant',\n              value: GraphTransform.Constant,\n              description: 'The first value will be shown as a constant line',\n            },\n            {\n              label: 'Negative Y',\n              value: GraphTransform.NegativeY,\n              description: 'Flip the results to negative values on the y axis',\n            },\n          ],\n          isClearable: true,\n        },\n        hideFromDefaults: true,\n      });\n\n      builder.addCustomEditor({\n        id: 'thresholdsStyle',\n        path: 'thresholdsStyle',\n        name: 'Show thresholds',\n        category: ['Thresholds'],\n        defaultValue: { mode: GraphThresholdsStyleMode.Off },\n        settings: {\n          options: graphFieldOptions.thresholdsDisplayModes,\n        },\n        editor: ThresholdsStyleEditor,\n        override: ThresholdsStyleEditor,\n        process: identityOverrideProcessor,\n        shouldApply: () => true,\n      });\n\n      commonOptionsBuilder.addAxisConfig(builder, cfg);\n      commonOptionsBuilder.addHideFrom(builder);\n    },\n  })\n  .setPanelOptions((builder) => {\n    builder\n      .addFieldNamePicker({\n        path: 'xField',\n        name: 'X Axis',\n        settings: {\n          placeholderText: 'First string or time field',\n        },\n      })\n      .addRadio({\n        path: 'orientation',\n        name: 'Orientation',\n        settings: {\n          options: [\n            { value: VizOrientation.Auto, label: 'Auto' },\n            { value: VizOrientation.Horizontal, label: 'Horizontal' },\n            { value: VizOrientation.Vertical, label: 'Vertical' },\n          ],\n        },\n        defaultValue: defaultOptions.orientation,\n      })\n      .addSliderInput({\n        path: 'xTickLabelRotation',\n        name: 'Rotate x-axis tick labels',\n        defaultValue: defaultOptions.xTickLabelRotation,\n        settings: {\n          min: -90,\n          max: 90,\n          step: 15,\n          marks: { '-90': '-90', '-45': '-45', 0: '0', 45: '45', 90: '90' },\n          included: false,\n        },\n      })\n      .addNumberInput({\n        path: 'xTickLabelMaxLength',\n        name: 'X-axis tick label max length',\n        description: 'X-axis labels will be truncated to the length provided',\n        settings: {\n          placeholder: 'None',\n          min: 0,\n        },\n        showIf: (opts) => opts.xTickLabelRotation !== 0,\n      })\n      .addCustomEditor({\n        id: 'xTickLabelSpacing',\n        path: 'xTickLabelSpacing',\n        name: 'X-axis labels minimum spacing',\n        defaultValue: defaultOptions.xTickLabelSpacing,\n        editor: TickSpacingEditor,\n      })\n      .addRadio({\n        path: 'showValue',\n        name: 'Show values',\n        settings: {\n          options: [\n            { value: VisibilityMode.Auto, label: 'Auto' },\n            { value: VisibilityMode.Always, label: 'Always' },\n            { value: VisibilityMode.Never, label: 'Never' },\n          ],\n        },\n        defaultValue: defaultOptions.showValue,\n      })\n      .addRadio({\n        path: 'stacking',\n        name: 'Stacking',\n        settings: {\n          options: graphFieldOptions.stacking,\n        },\n        defaultValue: defaultOptions.stacking,\n      })\n      .addSliderInput({\n        path: 'groupWidth',\n        name: 'Group width',\n        defaultValue: defaultOptions.groupWidth,\n        settings: {\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n        showIf: (c, data) => {\n          if (c.stacking && c.stacking !== StackingMode.None) {\n            return false;\n          }\n          return countNumberFields(data) !== 1;\n        },\n      })\n      .addSliderInput({\n        path: 'barWidth',\n        name: 'Bar width',\n        defaultValue: defaultOptions.barWidth,\n        settings: {\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n      })\n      .addSliderInput({\n        path: 'barRadius',\n        name: 'Bar radius',\n        defaultValue: defaultOptions.barRadius,\n        settings: {\n          min: 0,\n          max: 0.5,\n          step: 0.05,\n        },\n      })\n      .addBooleanSwitch({\n        path: 'fullHighlight',\n        name: 'Highlight full area on hover',\n        defaultValue: defaultOptions.fullHighlight,\n        showIf: (c) => c.stacking === StackingMode.None,\n      });\n\n    builder.addFieldNamePicker({\n      path: 'colorByField',\n      name: 'Color by field',\n      description: 'Use the color value for a sibling field to color each bar value.',\n    });\n\n    commonOptionsBuilder.addTooltipOptions(builder, false, false, optsWithHideZeros);\n    commonOptionsBuilder.addLegendOptions(builder);\n    commonOptionsBuilder.addTextSizeOptions(builder, false);\n  })\n  .setSuggestionsSupplier(new BarChartSuggestionsSupplier());\n\nfunction countNumberFields(data?: DataFrame[]): number {\n  let count = 0;\n  if (data) {\n    for (const frame of data) {\n      for (const field of frame.fields) {\n        if (field.type === FieldType.number) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}\n","import { ReactNode } from 'react';\n\nimport { DataFrame, Field, FieldType, formattedValueToString, InterpolateFunction, LinkModel } from '@grafana/data';\nimport { SortOrder, TooltipDisplayMode } from '@grafana/schema/dist/esm/common/common.gen';\nimport {\n  VizTooltipContent,\n  VizTooltipFooter,\n  VizTooltipHeader,\n  VizTooltipWrapper,\n  getContentItems,\n  VizTooltipItem,\n} from '@grafana/ui/internal';\n\nimport { getFieldActions } from '../status-history/utils';\nimport { fmt } from '../xychart/utils';\n\nimport { isTooltipScrollable } from './utils';\n\n// exemplar / annotation / time region hovering?\n// add annotation UI / alert dismiss UI?\n\nexport interface TimeSeriesTooltipProps {\n  // aligned series frame\n  series: DataFrame;\n\n  // aligned fields that are not series\n  _rest?: Field[];\n\n  // hovered points\n  dataIdxs: Array<number | null>;\n  // closest/hovered series\n  seriesIdx?: number | null;\n  mode?: TooltipDisplayMode;\n  sortOrder?: SortOrder;\n\n  isPinned: boolean;\n\n  annotate?: () => void;\n  maxHeight?: number;\n\n  replaceVariables?: InterpolateFunction;\n  dataLinks: LinkModel[];\n  hideZeros?: boolean;\n}\n\nexport const TimeSeriesTooltip = ({\n  series,\n  _rest,\n  dataIdxs,\n  seriesIdx,\n  mode = TooltipDisplayMode.Single,\n  sortOrder = SortOrder.None,\n  isPinned,\n  annotate,\n  maxHeight,\n  replaceVariables = (str) => str,\n  dataLinks,\n  hideZeros,\n}: TimeSeriesTooltipProps) => {\n  const xField = series.fields[0];\n  const xVal = formattedValueToString(xField.display!(xField.values[dataIdxs[0]!]));\n\n  const contentItems = getContentItems(\n    series.fields,\n    xField,\n    dataIdxs,\n    seriesIdx,\n    mode,\n    sortOrder,\n    (field) => field.type === FieldType.number || field.type === FieldType.enum,\n    hideZeros\n  );\n\n  _rest?.forEach((field) => {\n    if (!field.config.custom?.hideFrom?.tooltip) {\n      contentItems.push({\n        label: field.state?.displayName ?? field.name,\n        value: fmt(field, field.values[dataIdxs[0]!]),\n      });\n    }\n  });\n\n  let footer: ReactNode;\n\n  if (seriesIdx != null) {\n    const field = series.fields[seriesIdx];\n    const hasOneClickLink = dataLinks.some((dataLink) => dataLink.oneClick === true);\n\n    if (isPinned || hasOneClickLink) {\n      const dataIdx = dataIdxs[seriesIdx]!;\n      const actions = getFieldActions(series, field, replaceVariables, dataIdx);\n\n      footer = <VizTooltipFooter dataLinks={dataLinks} actions={actions} annotate={annotate} />;\n    }\n  }\n\n  const headerItem: VizTooltipItem | null = xField.config.custom?.hideFrom?.tooltip\n    ? null\n    : {\n        label: xField.type === FieldType.time ? '' : (xField.state?.displayName ?? xField.name),\n        value: xVal,\n      };\n\n  return (\n    <VizTooltipWrapper>\n      {headerItem != null && <VizTooltipHeader item={headerItem} isPinned={isPinned} />}\n      <VizTooltipContent\n        items={contentItems}\n        isPinned={isPinned}\n        scrollable={isTooltipScrollable({ mode, maxHeight })}\n        maxHeight={maxHeight}\n      />\n      {footer}\n    </VizTooltipWrapper>\n  );\n};\n","import {\n  DataFrame,\n  Field,\n  FieldType,\n  getDisplayProcessor,\n  GrafanaTheme2,\n  isBooleanUnit,\n  TimeRange,\n  cacheFieldDisplayNames,\n  applyNullInsertThreshold,\n  nullToValue,\n} from '@grafana/data';\nimport { convertFieldType } from '@grafana/data/internal';\nimport { GraphFieldConfig, LineInterpolation, TooltipDisplayMode, VizTooltipOptions } from '@grafana/schema';\nimport { buildScaleKey } from '@grafana/ui/internal';\n\nimport { HeatmapTooltip } from '../heatmap/panelcfg.gen';\n\ntype ScaleKey = string;\n\n// this will re-enumerate all enum fields on the same scale to create one ordinal progression\n// e.g. ['a','b'][0,1,0] + ['c','d'][1,0,1] -> ['a','b'][0,1,0] + ['c','d'][3,2,3]\nfunction reEnumFields(frames: DataFrame[]): DataFrame[] {\n  let allTextsByKey: Map<ScaleKey, string[]> = new Map();\n\n  let frames2: DataFrame[] = frames.map((frame) => {\n    return {\n      ...frame,\n      fields: frame.fields.map((field) => {\n        if (field.type === FieldType.enum) {\n          let scaleKey = buildScaleKey(field.config, field.type);\n          let allTexts = allTextsByKey.get(scaleKey);\n\n          if (!allTexts) {\n            allTexts = [];\n            allTextsByKey.set(scaleKey, allTexts);\n          }\n\n          let idxs: number[] = field.values.toArray().slice();\n          let txts = field.config.type!.enum!.text!;\n\n          // by-reference incrementing\n          if (allTexts.length > 0) {\n            for (let i = 0; i < idxs.length; i++) {\n              idxs[i] += allTexts.length;\n            }\n          }\n\n          allTexts.push(...txts);\n\n          // shared among all enum fields on same scale\n          field.config.type!.enum!.text! = allTexts;\n\n          return {\n            ...field,\n            values: idxs,\n          };\n\n          // TODO: update displayProcessor?\n        }\n\n        return field;\n      }),\n    };\n  });\n\n  return frames2;\n}\n\n/**\n * Returns null if there are no graphable fields\n */\nexport function prepareGraphableFields(\n  series: DataFrame[],\n  theme: GrafanaTheme2,\n  timeRange?: TimeRange,\n  // numeric X requires a single frame where the first field is numeric\n  xNumFieldIdx?: number\n): DataFrame[] | null {\n  if (!series?.length) {\n    return null;\n  }\n\n  cacheFieldDisplayNames(series);\n\n  let useNumericX = xNumFieldIdx != null;\n\n  // Make sure the numeric x field is first in the frame\n  if (xNumFieldIdx != null && xNumFieldIdx > 0) {\n    series = [\n      {\n        ...series[0],\n        fields: [series[0].fields[xNumFieldIdx], ...series[0].fields.filter((f, i) => i !== xNumFieldIdx)],\n      },\n    ];\n  }\n\n  // some datasources simply tag the field as time, but don't convert to milli epochs\n  // so we're stuck with doing the parsing here to avoid Moment slowness everywhere later\n  // this mutates (once)\n  for (let frame of series) {\n    for (let field of frame.fields) {\n      if (field.type === FieldType.time && typeof field.values[0] !== 'number') {\n        field.values = convertFieldType(field, { destinationType: FieldType.time }).values;\n      }\n    }\n  }\n\n  let enumFieldsCount = 0;\n\n  loopy: for (let frame of series) {\n    for (let field of frame.fields) {\n      if (field.type === FieldType.enum && ++enumFieldsCount > 1) {\n        series = reEnumFields(series);\n        break loopy;\n      }\n    }\n  }\n\n  let copy: Field;\n\n  const frames: DataFrame[] = [];\n\n  for (let frame of series) {\n    const fields: Field[] = [];\n\n    let hasTimeField = false;\n    let hasValueField = false;\n\n    let nulledFrame = useNumericX\n      ? frame\n      : applyNullInsertThreshold({\n          frame,\n          refFieldPseudoMin: timeRange?.from.valueOf(),\n          refFieldPseudoMax: timeRange?.to.valueOf(),\n        });\n\n    const frameFields = nullToValue(nulledFrame).fields;\n\n    for (let fieldIdx = 0; fieldIdx < (frameFields?.length || 0); fieldIdx++) {\n      const field = frameFields[fieldIdx];\n\n      switch (field.type) {\n        case FieldType.time:\n          hasTimeField = true;\n          fields.push(field);\n          break;\n        case FieldType.number:\n          hasValueField = useNumericX ? fieldIdx > 0 : true;\n          copy = {\n            ...field,\n            values: field.values.map((v) => {\n              if (!(Number.isFinite(v) || v == null)) {\n                return null;\n              }\n              return v;\n            }),\n          };\n\n          fields.push(copy);\n          break; // ok\n        case FieldType.enum:\n          hasValueField = true;\n        case FieldType.string:\n          copy = {\n            ...field,\n            values: field.values,\n          };\n\n          fields.push(copy);\n          break; // ok\n        case FieldType.boolean:\n          hasValueField = true;\n          const custom: GraphFieldConfig = field.config?.custom ?? {};\n          const config = {\n            ...field.config,\n            max: 1,\n            min: 0,\n            custom,\n          };\n\n          // smooth and linear do not make sense\n          if (custom.lineInterpolation !== LineInterpolation.StepBefore) {\n            custom.lineInterpolation = LineInterpolation.StepAfter;\n          }\n\n          copy = {\n            ...field,\n            config,\n            type: FieldType.number,\n            values: field.values.map((v) => {\n              if (v == null) {\n                return v;\n              }\n              return Boolean(v) ? 1 : 0;\n            }),\n          };\n\n          if (!isBooleanUnit(config.unit)) {\n            config.unit = 'bool';\n            copy.display = getDisplayProcessor({ field: copy, theme });\n          }\n\n          fields.push(copy);\n          break;\n      }\n    }\n\n    if ((useNumericX || hasTimeField) && hasValueField) {\n      frames.push({\n        ...frame,\n        length: nulledFrame.length,\n        fields,\n      });\n    }\n  }\n\n  if (frames.length) {\n    setClassicPaletteIdxs(frames, theme, 0);\n    matchEnumColorToSeriesColor(frames, theme);\n    return frames;\n  }\n\n  return null;\n}\n\nconst matchEnumColorToSeriesColor = (frames: DataFrame[], theme: GrafanaTheme2) => {\n  const { palette } = theme.visualization;\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.type === FieldType.enum) {\n        const namedColor = palette[field.state?.seriesIndex! % palette.length];\n        const hexColor = theme.visualization.getColorByName(namedColor);\n        const enumConfig = field.config.type!.enum!;\n\n        enumConfig.color = Array(enumConfig.text!.length).fill(hexColor);\n        field.display = getDisplayProcessor({ field, theme });\n      }\n    }\n  }\n};\n\nexport const setClassicPaletteIdxs = (frames: DataFrame[], theme: GrafanaTheme2, skipFieldIdx?: number) => {\n  let seriesIndex = 0;\n  frames.forEach((frame) => {\n    frame.fields.forEach((field, fieldIdx) => {\n      if (\n        fieldIdx !== skipFieldIdx &&\n        (field.type === FieldType.number || field.type === FieldType.boolean || field.type === FieldType.enum)\n      ) {\n        field.state = {\n          ...field.state,\n          seriesIndex: seriesIndex++, // TODO: skip this for fields with custom renderers (e.g. Candlestick)?\n        };\n        field.display = getDisplayProcessor({ field, theme });\n      }\n    });\n  });\n};\n\nexport function getTimezones(timezones: string[] | undefined, defaultTimezone: string): string[] {\n  if (!timezones || !timezones.length) {\n    return [defaultTimezone];\n  }\n  return timezones.map((v) => (v?.length ? v : defaultTimezone));\n}\n\nexport const isTooltipScrollable = (tooltipOptions: VizTooltipOptions | HeatmapTooltip) => {\n  return tooltipOptions.mode === TooltipDisplayMode.Multi && tooltipOptions.maxHeight != null;\n};\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as common from '@grafana/schema';\n\nexport enum PointShape {\n  Circle = 'circle',\n  Square = 'square',\n}\n\nexport enum SeriesMapping {\n  Auto = 'auto',\n  Manual = 'manual',\n}\n\nexport enum XYShowMode {\n  Lines = 'lines',\n  Points = 'points',\n  PointsAndLines = 'points+lines',\n}\n\n/**\n * NOTE: (copied from dashboard_kind.cue, since not exported)\n * Matcher is a predicate configuration. Based on the config a set of field(s) or values is filtered in order to apply override / transformation.\n * It comes with in id ( to resolve implementation from registry) and a configuration thats specific to a particular matcher type.\n */\nexport interface MatcherConfig {\n  /**\n   * The matcher id. This is used to find the matcher implementation from registry.\n   */\n  id: string;\n  /**\n   * The matcher options. This is specific to the matcher implementation.\n   */\n  options?: unknown;\n}\n\nexport const defaultMatcherConfig: Partial<MatcherConfig> = {\n  id: '',\n};\n\nexport interface FieldConfig extends common.HideableFieldConfig, common.AxisConfig {\n  fillOpacity?: number;\n  lineStyle?: common.LineStyle;\n  lineWidth?: number;\n  pointShape?: PointShape;\n  pointSize?: {\n    fixed?: number;\n    min?: number;\n    max?: number;\n  };\n  pointStrokeWidth?: number;\n  show?: XYShowMode;\n}\n\nexport const defaultFieldConfig: Partial<FieldConfig> = {\n  fillOpacity: 50,\n  show: XYShowMode.Points,\n};\n\nexport interface XYSeriesConfig {\n  color?: {\n    matcher: MatcherConfig;\n  };\n  frame?: {\n    matcher: MatcherConfig;\n  };\n  name?: {\n    fixed?: string;\n  };\n  size?: {\n    matcher: MatcherConfig;\n  };\n  x?: {\n    matcher: MatcherConfig;\n  };\n  y?: {\n    matcher: MatcherConfig;\n  };\n}\n\nexport interface Options extends common.OptionsWithLegend, common.OptionsWithTooltip {\n  mapping: SeriesMapping;\n  series: Array<XYSeriesConfig>;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  series: [],\n};\n","import {\n  Field,\n  formattedValueToString,\n  getFieldMatcher,\n  FieldType,\n  getFieldDisplayName,\n  DataFrame,\n  FrameMatcherID,\n  MatcherConfig,\n  FieldColorModeId,\n  cacheFieldDisplayNames,\n  FieldMatcherID,\n  FieldConfigSource,\n} from '@grafana/data';\nimport { decoupleHideFromState } from '@grafana/data/internal';\nimport { config } from '@grafana/runtime';\nimport { VisibilityMode } from '@grafana/schema';\n\nimport { XYShowMode, SeriesMapping, XYSeriesConfig } from './panelcfg.gen';\nimport { XYSeries } from './types2';\n\nexport function fmt(field: Field, val: number): string {\n  if (field.display) {\n    return formattedValueToString(field.display(val));\n  }\n\n  return `${val}`;\n}\n\n// cause we dont have a proper matcher for this currently\nfunction getFrameMatcher2(config: MatcherConfig) {\n  if (config.id === FrameMatcherID.byIndex) {\n    return (frame: DataFrame, index: number) => index === config.options;\n  }\n\n  return () => false;\n}\n\nexport function prepSeries(\n  mapping: SeriesMapping,\n  mappedSeries: XYSeriesConfig[],\n  frames: DataFrame[],\n  fieldConfig: FieldConfigSource\n) {\n  cacheFieldDisplayNames(frames);\n  decoupleHideFromState(frames, fieldConfig);\n\n  let series: XYSeries[] = [];\n\n  if (mappedSeries.length === 0) {\n    mappedSeries = [{}];\n  }\n\n  const { palette, getColorByName } = config.theme2.visualization;\n\n  mappedSeries.forEach((seriesCfg, seriesIdx) => {\n    if (mapping === SeriesMapping.Manual) {\n      if (seriesCfg.frame?.matcher == null || seriesCfg.x?.matcher == null || seriesCfg.y?.matcher == null) {\n        return;\n      }\n    }\n\n    let xMatcher = getFieldMatcher(\n      seriesCfg.x?.matcher ?? {\n        id: FieldMatcherID.byType,\n        options: 'number',\n      }\n    );\n    let yMatcher = getFieldMatcher(\n      seriesCfg.y?.matcher ?? {\n        id: FieldMatcherID.byType,\n        options: 'number',\n      }\n    );\n    let colorMatcher = seriesCfg.color ? getFieldMatcher(seriesCfg.color.matcher) : null;\n    let sizeMatcher = seriesCfg.size ? getFieldMatcher(seriesCfg.size.matcher) : null;\n    // let frameMatcher = seriesCfg.frame ? getFrameMatchers(seriesCfg.frame) : null;\n    let frameMatcher = seriesCfg.frame ? getFrameMatcher2(seriesCfg.frame.matcher) : null;\n\n    // loop over all frames and fields, adding a new series for each y dim\n    frames.forEach((frame, frameIdx) => {\n      // must match frame in manual mode\n      if (frameMatcher != null && !frameMatcher(frame, frameIdx)) {\n        return;\n      }\n\n      // shared across each series in this frame\n      let restFields: Field[] = [];\n\n      let frameSeries: XYSeries[] = [];\n\n      // only grabbing number fields (exclude time, string, enum, other)\n      let onlyNumFields = frame.fields.filter((field) => field.type === FieldType.number);\n\n      // only one of these per frame\n      let x = onlyNumFields.find((field) => xMatcher(field, frame, frames));\n      let color =\n        colorMatcher != null\n          ? onlyNumFields.find((field) => field !== x && colorMatcher!(field, frame, frames))\n          : undefined;\n      let size =\n        sizeMatcher != null\n          ? onlyNumFields.find((field) => field !== x && field !== color && sizeMatcher!(field, frame, frames))\n          : undefined;\n\n      // x field is required\n      if (x != null) {\n        // match y fields and create series\n        onlyNumFields.forEach((field) => {\n          if (field === x) {\n            return;\n          }\n\n          // in auto mode don't reuse already-mapped fields\n          if (mapping === SeriesMapping.Auto && (field === color || field === size)) {\n            return;\n          }\n\n          // in manual mode only add single series for this config\n          if (mapping === SeriesMapping.Manual && frameSeries.length > 0) {\n            return;\n          }\n\n          // if we match non-excluded y, create series\n          if (yMatcher(field, frame, frames) && !field.config.custom?.hideFrom?.viz) {\n            let y = field;\n\n            let name = seriesCfg.name?.fixed;\n\n            if (name == null) {\n              // if the displayed field name is likely to have a common prefix or suffix\n              // (such as those from Partition by values transformation)\n              const likelyHasCommonParts =\n                frames.length > 1 && (frame.name != null || Object.keys(y.labels ?? {}).length > 0);\n\n              // if the field was explictly (re)named using config.displayName or config.displayNameFromDS\n              // we still want to retain any frame name prefix or suffix so that autoNameSeries() can\n              // properly detect + strip common parts across all series...\n              const { displayName, displayNameFromDS } = y.config;\n              const hasExplicitName = displayName != null || displayNameFromDS != null;\n\n              if (likelyHasCommonParts && hasExplicitName) {\n                // ...and a hacky way to do this is to temp remove the explicit name, get the auto name, then revert\n                const stateDisplayName = y.state!.displayName;\n\n                // clear config and cache\n                y.config.displayName = y.config.displayNameFromDS = y.state!.displayName = undefined;\n                // get default/calculated display name (maybe use calculateFieldDisplayName() here instead?)\n                name = getFieldDisplayName(y, frame, frames);\n                // replace original field name with explicit one\n                name = name.replace(y.name, (displayNameFromDS ?? displayName)!);\n\n                // revert\n                y.config.displayName = displayName;\n                y.config.displayNameFromDS = displayNameFromDS;\n                y.state!.displayName = stateDisplayName;\n              } else {\n                name = getFieldDisplayName(y, frame, frames);\n              }\n            }\n\n            let ser: XYSeries = {\n              // these typically come from y field\n              name: {\n                value: name,\n              },\n\n              showPoints: y.config.custom.show === XYShowMode.Lines ? VisibilityMode.Never : VisibilityMode.Always,\n              pointShape: y.config.custom.pointShape,\n              pointStrokeWidth: y.config.custom.pointStrokeWidth,\n              fillOpacity: y.config.custom.fillOpacity,\n\n              showLine: y.config.custom.show !== XYShowMode.Points,\n              lineWidth: y.config.custom.lineWidth ?? 2,\n              lineStyle: y.config.custom.lineStyle,\n\n              x: {\n                field: x!,\n              },\n              y: {\n                field: y,\n              },\n              color: {},\n              size: {},\n              _rest: restFields,\n            };\n\n            if (color != null) {\n              ser.color.field = color;\n            }\n\n            if (size != null) {\n              ser.size.field = size;\n              ser.size.min = size.config.custom.pointSize?.min ?? 5;\n              ser.size.max = size.config.custom.pointSize?.max ?? 100;\n              // ser.size.mode =\n            }\n\n            frameSeries.push(ser);\n          }\n        });\n\n        if (frameSeries.length === 0) {\n          // TODO: could not create series, skip & show error?\n        }\n\n        // populate rest fields\n        frame.fields.forEach((field) => {\n          let isUsedField = frameSeries.some(\n            ({ x, y, color, size }) =>\n              x.field === field || y.field === field || color.field === field || size.field === field\n          );\n\n          if (!isUsedField) {\n            restFields.push(field);\n          }\n        });\n\n        series.push(...frameSeries);\n      } else {\n        // x is missing in this frame!\n      }\n    });\n  });\n\n  if (series.length === 0) {\n    // TODO: could not create series, skip & show error?\n  } else {\n    // assign classic palette colors by index, as fallbacks for all series\n\n    let paletteIdx = 0;\n\n    // todo: populate min, max, mode from field + hints\n    series.forEach((s, i) => {\n      if (s.color.field == null) {\n        // derive fixed color from y field config\n        let colorCfg = s.y.field.config.color ?? { mode: FieldColorModeId.PaletteClassic };\n\n        let value = '';\n\n        if (colorCfg.mode === FieldColorModeId.PaletteClassic) {\n          value = getColorByName(palette[paletteIdx++ % palette.length]); // todo: do this via state.seriesIdx and re-init displayProcessor\n        } else if (colorCfg.mode === FieldColorModeId.Fixed) {\n          value = getColorByName(colorCfg.fixedColor!);\n        }\n\n        s.color.fixed = value;\n      }\n\n      if (s.size.field == null) {\n        // derive fixed size from y field config\n        s.size.fixed = s.y.field.config.custom.pointSize?.fixed ?? 5;\n        // ser.size.mode =\n      }\n    });\n\n    autoNameSeries(series);\n\n    // TODO: re-assign y display names?\n    // y.state = {\n    //   ...y.state,\n    //   seriesIndex: series.length + ,\n    // };\n    // y.display = getDisplayProcessor({ field, theme });\n  }\n\n  return series;\n}\n\n// strip common prefixes and suffixes from y field names\nfunction autoNameSeries(series: XYSeries[]) {\n  let names = series.map((s) => s.name.value.split(/\\s+/g));\n\n  const { prefix, suffix } = findCommonPrefixSuffixLengths(names);\n\n  if (prefix < Infinity || suffix < Infinity) {\n    series.forEach((s, i) => {\n      s.name.value = names[i].slice(prefix, names[i].length - suffix).join(' ');\n    });\n  }\n}\n\nexport function getCommonPrefixSuffix(strs: string[]) {\n  let names = strs.map((s) => s.split(/\\s+/g));\n\n  let { prefix, suffix } = findCommonPrefixSuffixLengths(names);\n\n  let n = names[0];\n\n  if (n.length === 1 && prefix === 1 && suffix === 1) {\n    return '';\n  }\n\n  let parts = [];\n\n  if (prefix > 0) {\n    parts.push(...n.slice(0, prefix));\n  }\n\n  if (suffix > 0) {\n    parts.push(...n.slice(-suffix));\n  }\n\n  return parts.join(' ');\n}\n\n// lengths are in number of tokens (segments) in a phrase\nfunction findCommonPrefixSuffixLengths(names: string[][]) {\n  let commonPrefixLen = Infinity;\n  let commonSuffixLen = Infinity;\n\n  // if auto naming strategy, rename fields by stripping common prefixes and suffixes\n  let segs0: string[] = names[0];\n\n  for (let i = 1; i < names.length; i++) {\n    if (names[i].length < segs0.length) {\n      segs0 = names[i];\n    }\n  }\n\n  for (let i = 1; i < names.length; i++) {\n    let segs = names[i];\n\n    if (segs !== segs0) {\n      // prefixes\n      let preLen = 0;\n      for (let j = 0; j < segs0.length; j++) {\n        if (segs[j] === segs0[j]) {\n          preLen++;\n        } else {\n          break;\n        }\n      }\n\n      if (preLen < commonPrefixLen) {\n        commonPrefixLen = preLen;\n      }\n\n      // suffixes\n      let sufLen = 0;\n      for (let j = segs0.length - 1; j >= 0; j--) {\n        if (segs[j] === segs0[j]) {\n          sufLen++;\n        } else {\n          break;\n        }\n      }\n\n      if (sufLen < commonSuffixLen) {\n        commonSuffixLen = sufLen;\n      }\n    }\n  }\n\n  return {\n    prefix: commonPrefixLen,\n    suffix: commonSuffixLen,\n  };\n}\n"],"names":["VizTooltipWrapper","children","className","styles","getStyles","theme","hasVisibleLegendSeries","config","data","field","BarChartLegend","placement","calcs","displayMode","colorField","vizLayoutLegendProps","fieldConfig","colorMode","thresholdItems","thresholdsAbsolute","thresholdsPercent","i","step","thresholdAbsoluteItems","thresholdPercentItems","valueMappings","mappings","mapping","valueMappingItems","legendItems","fieldIndex","label","color","VizLayout","VizLegend","intervals","groupDistr","barDistr","VALUE_MIN_FONT_SIZE","VALUE_MAX_FONT_SIZE","BAR_FONT_SIZE_RATIO","LABEL_OFFSET_FACTOR_VT","LABEL_OFFSET_FACTOR_HZ","LABEL_OFFSET_MAX_VT","LABEL_OFFSET_MAX_HZ","MIDDLE_BASELINE_SHIFT","calculateFontSizeWithMetrics","text","width","height","lineHeight","maxSize","textSize","measureText","fontSizeBasedOnWidth","fontSizeBasedOnHeight","optimalSize","getConfig","opts","xOri","dir","rawValue","getColor","formatValue","formatShortValue","fillOpacity","showValue","xSpacing","hoverMulti","timeZone","isXHorizontal","hasAutoValueSize","isStacked","pctStacked","groupWidth","barWidth","barRadius","qt","hovered","hRect","xSplits","u","v","hFilter","splits","dim","_dir","dataLen","lastIdx","skipMod","cssDim","maxTicks","splits2","xValues","axisIdx","foundSpace","foundIncr","format","xRange","min","max","pctOffset","distribute","di","lftPct","widPct","rn","offset","distrTwo","groupCount","barCount","out","groupIdx","groupOffPct","groupDimPct","barIdx","barOffPct","barDimPct","distrOne","LABEL_OFFSET_FACTOR","LABEL_OFFSET_MAX","barsPctLayout","barsColors","scaleFactor","labels","fontSize","labelOffset","vSpace","hSpace","useMappedColors","mappedColorDisp","seriesIdx","barsBuilder","dataIdx","lft","top","wid","hgt","val","barRect","raw","divider","alignedTotals","calculatedSize","textMetrics","autoFontSize","middleShift","value","x","y","xAdjust","yAdjust","init","el","cursor","cx","cy","o","r","hRect2","isHovered","drawClear","s","colors","valueIdx","c","colorManipulator","draw","curAlign","curBaseline","didx","first","sidx","align","baseline","bbox","intersectsLabel","subsidx","label2","bbox2","hidden","prepData","frames","stackingGroups","totals","defaultOptions","defaultFieldConfig","prepSeries","stacking","xFieldName","colorFieldName","fr","frame","timeFieldIdx","f","xField","fields","_rest","field2","warn","series","prepConfig","totalSeries","orientation","options","tooltip","xTickLabelRotation","xTickLabelMaxLength","xTickLabelSpacing","legend","fullHighlight","builder","UPlotConfigBuilder","formatters","shortenValue","vizOrientation","getScaleOrientation","disp","m","result","lftSpace","btmSpace","getRotationPadding","xFieldAxisPlacement","xFieldAxisShow","customConfig","scaleKey","seriesColor","softMin","softMax","axisOpts","decimals","_series","_color","length","rotateLabel","valueMaxLength","values","displayProcessor","getProcessedValue","maxLength","size","paddingRight","paddingLeft","paddingBottom","charWidth","toRads","BarChartPanel","props","id","replaceVariables","colorByField","info","vizSeries","xGroupsCount","seriesCount","plotData","PanelDataErrorView","legendComp","vizWidth","vizHeight","TooltipPlugin2","dataIdxs","isPinned","dismiss","timeRange2","viaSync","dataLinks","TimeSeriesTooltip","GAPS_OPTIONS","TickSpacingEditor","isRTL","gap","onSpacingChange","onRTLChange","RadioButtonGroup","Tooltip","Checkbox","changeToBarChartPanelMigrationHandler","panel","prevPluginId","prevOptions","graphOptions","transformations","getReducer","reducers","transformReducers","reducer","BarChartSuggestionsSupplier","list","dataSummary","PanelPlugin","cfg","ThresholdsStyleEditor","countNumberFields","count","mode","sortOrder","annotate","maxHeight","str","hideZeros","xVal","contentItems","footer","hasOneClickLink","dataLink","actions","headerItem","reEnumFields","allTextsByKey","allTexts","idxs","txts","prepareGraphableFields","timeRange","xNumFieldIdx","useNumericX","enumFieldsCount","loopy","copy","hasTimeField","hasValueField","nulledFrame","frameFields","fieldIdx","custom","setClassicPaletteIdxs","matchEnumColorToSeriesColor","palette","namedColor","hexColor","enumConfig","skipFieldIdx","seriesIndex","getTimezones","timezones","defaultTimezone","isTooltipScrollable","tooltipOptions","PointShape","SeriesMapping","XYShowMode","defaultMatcherConfig","fmt","getFrameMatcher2","index","mappedSeries","getColorByName","seriesCfg","xMatcher","yMatcher","colorMatcher","sizeMatcher","frameMatcher","frameIdx","restFields","frameSeries","onlyNumFields","name","likelyHasCommonParts","displayName","displayNameFromDS","hasExplicitName","stateDisplayName","ser","paletteIdx","colorCfg","autoNameSeries","names","prefix","suffix","findCommonPrefixSuffixLengths","getCommonPrefixSuffix","strs","n","parts","commonPrefixLen","commonSuffixLen","segs0","segs","preLen","j","sufLen"],"sourceRoot":""}